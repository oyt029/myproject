// $ANTLR 3.5 PhoenixSQL.g 2014-12-26 08:40:01

/**
 * Copyright 2010 The Apache Software Foundation
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.phoenix.parse;
///CLOVER:OFF


import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;

@SuppressWarnings("all")
public class PhoenixSQLLexer extends Lexer {
	public static final int EOF=-1;
	public static final int ADD=4;
	public static final int ALL=5;
	public static final int ALTER=6;
	public static final int AND=7;
	public static final int ANY=8;
	public static final int ARRAY=9;
	public static final int AS=10;
	public static final int ASC=11;
	public static final int ASTERISK=12;
	public static final int AT=13;
	public static final int BETWEEN=14;
	public static final int BIND_NAME=15;
	public static final int BY=16;
	public static final int CACHE=17;
	public static final int CASCADE=18;
	public static final int CASE=19;
	public static final int CAST=20;
	public static final int CHAR=21;
	public static final int CHAR_ESC=22;
	public static final int COLON=23;
	public static final int COLUMN=24;
	public static final int COLUMNS=25;
	public static final int COMMA=26;
	public static final int COMMENT_AND_HINT_END=27;
	public static final int COMMENT_START=28;
	public static final int CONCAT=29;
	public static final int CONSTRAINT=30;
	public static final int CREATE=31;
	public static final int CURRENT=32;
	public static final int CYCLE=33;
	public static final int DBL_QUOTE_CHAR=34;
	public static final int DECIMAL=35;
	public static final int DELETE=36;
	public static final int DESC=37;
	public static final int DIGIT=38;
	public static final int DISABLE=39;
	public static final int DISTINCT=40;
	public static final int DIVIDE=41;
	public static final int DOT=42;
	public static final int DOUBLE=43;
	public static final int DOUBLE_EQ=44;
	public static final int DOUBLE_QUOTE=45;
	public static final int DROP=46;
	public static final int ELSE=47;
	public static final int END=48;
	public static final int EOL=49;
	public static final int EQ=50;
	public static final int EXISTS=51;
	public static final int EXPLAIN=52;
	public static final int FALSE=53;
	public static final int FIELDCHAR=54;
	public static final int FIRST=55;
	public static final int FOR=56;
	public static final int FROM=57;
	public static final int FULL=58;
	public static final int GROUP=59;
	public static final int GT=60;
	public static final int HAVING=61;
	public static final int HINT_START=62;
	public static final int IF=63;
	public static final int ILIKE=64;
	public static final int IN=65;
	public static final int INCLUDE=66;
	public static final int INCREMENT=67;
	public static final int INDEX=68;
	public static final int INNER=69;
	public static final int INTO=70;
	public static final int IS=71;
	public static final int JOIN=72;
	public static final int KEY=73;
	public static final int LAST=74;
	public static final int LCURLY=75;
	public static final int LEFT=76;
	public static final int LETTER=77;
	public static final int LIKE=78;
	public static final int LIMIT=79;
	public static final int LOCAL=80;
	public static final int LONG=81;
	public static final int LPAREN=82;
	public static final int LSQUARE=83;
	public static final int LT=84;
	public static final int MAXVALUE=85;
	public static final int MINUS=86;
	public static final int MINVALUE=87;
	public static final int ML_COMMENT=88;
	public static final int ML_HINT=89;
	public static final int NAME=90;
	public static final int NEXT=91;
	public static final int NOEQ1=92;
	public static final int NOEQ2=93;
	public static final int NOT=94;
	public static final int NULL=95;
	public static final int NULLS=96;
	public static final int NUMBER=97;
	public static final int ON=98;
	public static final int OR=99;
	public static final int ORDER=100;
	public static final int OTHER=101;
	public static final int OUTER=102;
	public static final int OUTER_JOIN=103;
	public static final int PERCENT=104;
	public static final int PLUS=105;
	public static final int POSINTEGER=106;
	public static final int PRIMARY=107;
	public static final int QUESTION=108;
	public static final int RCURLY=109;
	public static final int REBUILD=110;
	public static final int RIGHT=111;
	public static final int RPAREN=112;
	public static final int RSQUARE=113;
	public static final int SELECT=114;
	public static final int SEMICOLON=115;
	public static final int SEQUENCE=116;
	public static final int SET=117;
	public static final int SL_COMMENT=118;
	public static final int SL_COMMENT1=119;
	public static final int SL_COMMENT2=120;
	public static final int SOME=121;
	public static final int SPLIT=122;
	public static final int START=123;
	public static final int STATISTICS=124;
	public static final int STRING_LITERAL=125;
	public static final int TABLE=126;
	public static final int TABLES=127;
	public static final int THEN=128;
	public static final int TILDE=129;
	public static final int TRUE=130;
	public static final int UNUSABLE=131;
	public static final int UPDATE=132;
	public static final int UPSERT=133;
	public static final int USABLE=134;
	public static final int VALUE=135;
	public static final int VALUES=136;
	public static final int VIEW=137;
	public static final int WHEN=138;
	public static final int WHERE=139;
	public static final int WITH=140;
	public static final int WITHIN=141;
	public static final int WS=142;




	// delegates
	// delegators
	public Lexer[] getDelegates() {
		return new Lexer[] {};
	}

	public PhoenixSQLLexer() {} 
	public PhoenixSQLLexer(CharStream input) {
		this(input, new RecognizerSharedState());
	}
	public PhoenixSQLLexer(CharStream input, RecognizerSharedState state) {
		super(input,state);
	}
	@Override public String getGrammarFileName() { return "PhoenixSQL.g"; }

	// $ANTLR start "ADD"
	public final void mADD() throws RecognitionException {
		try {
			int _type = ADD;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:29:5: ( 'add' )
			// PhoenixSQL.g:29:7: 'add'
			{
			match("add"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ADD"

	// $ANTLR start "ALL"
	public final void mALL() throws RecognitionException {
		try {
			int _type = ALL;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:30:5: ( 'all' )
			// PhoenixSQL.g:30:7: 'all'
			{
			match("all"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ALL"

	// $ANTLR start "ALTER"
	public final void mALTER() throws RecognitionException {
		try {
			int _type = ALTER;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:31:7: ( 'alter' )
			// PhoenixSQL.g:31:9: 'alter'
			{
			match("alter"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ALTER"

	// $ANTLR start "AND"
	public final void mAND() throws RecognitionException {
		try {
			int _type = AND;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:32:5: ( 'and' )
			// PhoenixSQL.g:32:7: 'and'
			{
			match("and"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "AND"

	// $ANTLR start "ANY"
	public final void mANY() throws RecognitionException {
		try {
			int _type = ANY;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:33:5: ( 'any' )
			// PhoenixSQL.g:33:7: 'any'
			{
			match("any"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ANY"

	// $ANTLR start "ARRAY"
	public final void mARRAY() throws RecognitionException {
		try {
			int _type = ARRAY;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:34:7: ( 'array' )
			// PhoenixSQL.g:34:9: 'array'
			{
			match("array"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ARRAY"

	// $ANTLR start "AS"
	public final void mAS() throws RecognitionException {
		try {
			int _type = AS;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:35:4: ( 'as' )
			// PhoenixSQL.g:35:6: 'as'
			{
			match("as"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "AS"

	// $ANTLR start "ASC"
	public final void mASC() throws RecognitionException {
		try {
			int _type = ASC;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:36:5: ( 'asc' )
			// PhoenixSQL.g:36:7: 'asc'
			{
			match("asc"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ASC"

	// $ANTLR start "BETWEEN"
	public final void mBETWEEN() throws RecognitionException {
		try {
			int _type = BETWEEN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:37:9: ( 'between' )
			// PhoenixSQL.g:37:11: 'between'
			{
			match("between"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "BETWEEN"

	// $ANTLR start "BY"
	public final void mBY() throws RecognitionException {
		try {
			int _type = BY;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:38:4: ( 'by' )
			// PhoenixSQL.g:38:6: 'by'
			{
			match("by"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "BY"

	// $ANTLR start "CACHE"
	public final void mCACHE() throws RecognitionException {
		try {
			int _type = CACHE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:39:7: ( 'cache' )
			// PhoenixSQL.g:39:9: 'cache'
			{
			match("cache"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "CACHE"

	// $ANTLR start "CASCADE"
	public final void mCASCADE() throws RecognitionException {
		try {
			int _type = CASCADE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:40:9: ( 'cascade' )
			// PhoenixSQL.g:40:11: 'cascade'
			{
			match("cascade"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "CASCADE"

	// $ANTLR start "CASE"
	public final void mCASE() throws RecognitionException {
		try {
			int _type = CASE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:41:6: ( 'case' )
			// PhoenixSQL.g:41:8: 'case'
			{
			match("case"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "CASE"

	// $ANTLR start "CAST"
	public final void mCAST() throws RecognitionException {
		try {
			int _type = CAST;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:42:6: ( 'cast' )
			// PhoenixSQL.g:42:8: 'cast'
			{
			match("cast"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "CAST"

	// $ANTLR start "COLUMN"
	public final void mCOLUMN() throws RecognitionException {
		try {
			int _type = COLUMN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:43:8: ( 'column' )
			// PhoenixSQL.g:43:10: 'column'
			{
			match("column"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "COLUMN"

	// $ANTLR start "COLUMNS"
	public final void mCOLUMNS() throws RecognitionException {
		try {
			int _type = COLUMNS;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:44:9: ( 'columns' )
			// PhoenixSQL.g:44:11: 'columns'
			{
			match("columns"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "COLUMNS"

	// $ANTLR start "CONSTRAINT"
	public final void mCONSTRAINT() throws RecognitionException {
		try {
			int _type = CONSTRAINT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:45:12: ( 'constraint' )
			// PhoenixSQL.g:45:14: 'constraint'
			{
			match("constraint"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "CONSTRAINT"

	// $ANTLR start "CREATE"
	public final void mCREATE() throws RecognitionException {
		try {
			int _type = CREATE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:46:8: ( 'create' )
			// PhoenixSQL.g:46:10: 'create'
			{
			match("create"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "CREATE"

	// $ANTLR start "CURRENT"
	public final void mCURRENT() throws RecognitionException {
		try {
			int _type = CURRENT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:47:9: ( 'current' )
			// PhoenixSQL.g:47:11: 'current'
			{
			match("current"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "CURRENT"

	// $ANTLR start "CYCLE"
	public final void mCYCLE() throws RecognitionException {
		try {
			int _type = CYCLE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:48:7: ( 'cycle' )
			// PhoenixSQL.g:48:9: 'cycle'
			{
			match("cycle"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "CYCLE"

	// $ANTLR start "DELETE"
	public final void mDELETE() throws RecognitionException {
		try {
			int _type = DELETE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:49:8: ( 'delete' )
			// PhoenixSQL.g:49:10: 'delete'
			{
			match("delete"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DELETE"

	// $ANTLR start "DESC"
	public final void mDESC() throws RecognitionException {
		try {
			int _type = DESC;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:50:6: ( 'desc' )
			// PhoenixSQL.g:50:8: 'desc'
			{
			match("desc"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DESC"

	// $ANTLR start "DISABLE"
	public final void mDISABLE() throws RecognitionException {
		try {
			int _type = DISABLE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:51:9: ( 'disable' )
			// PhoenixSQL.g:51:11: 'disable'
			{
			match("disable"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DISABLE"

	// $ANTLR start "DISTINCT"
	public final void mDISTINCT() throws RecognitionException {
		try {
			int _type = DISTINCT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:52:10: ( 'distinct' )
			// PhoenixSQL.g:52:12: 'distinct'
			{
			match("distinct"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DISTINCT"

	// $ANTLR start "DROP"
	public final void mDROP() throws RecognitionException {
		try {
			int _type = DROP;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:53:6: ( 'drop' )
			// PhoenixSQL.g:53:8: 'drop'
			{
			match("drop"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DROP"

	// $ANTLR start "ELSE"
	public final void mELSE() throws RecognitionException {
		try {
			int _type = ELSE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:54:6: ( 'else' )
			// PhoenixSQL.g:54:8: 'else'
			{
			match("else"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ELSE"

	// $ANTLR start "END"
	public final void mEND() throws RecognitionException {
		try {
			int _type = END;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:55:5: ( 'end' )
			// PhoenixSQL.g:55:7: 'end'
			{
			match("end"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "END"

	// $ANTLR start "EXISTS"
	public final void mEXISTS() throws RecognitionException {
		try {
			int _type = EXISTS;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:56:8: ( 'exists' )
			// PhoenixSQL.g:56:10: 'exists'
			{
			match("exists"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "EXISTS"

	// $ANTLR start "EXPLAIN"
	public final void mEXPLAIN() throws RecognitionException {
		try {
			int _type = EXPLAIN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:57:9: ( 'explain' )
			// PhoenixSQL.g:57:11: 'explain'
			{
			match("explain"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "EXPLAIN"

	// $ANTLR start "FALSE"
	public final void mFALSE() throws RecognitionException {
		try {
			int _type = FALSE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:58:7: ( 'false' )
			// PhoenixSQL.g:58:9: 'false'
			{
			match("false"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "FALSE"

	// $ANTLR start "FIRST"
	public final void mFIRST() throws RecognitionException {
		try {
			int _type = FIRST;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:59:7: ( 'first' )
			// PhoenixSQL.g:59:9: 'first'
			{
			match("first"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "FIRST"

	// $ANTLR start "FOR"
	public final void mFOR() throws RecognitionException {
		try {
			int _type = FOR;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:60:5: ( 'for' )
			// PhoenixSQL.g:60:7: 'for'
			{
			match("for"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "FOR"

	// $ANTLR start "FROM"
	public final void mFROM() throws RecognitionException {
		try {
			int _type = FROM;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:61:6: ( 'from' )
			// PhoenixSQL.g:61:8: 'from'
			{
			match("from"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "FROM"

	// $ANTLR start "FULL"
	public final void mFULL() throws RecognitionException {
		try {
			int _type = FULL;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:62:6: ( 'full' )
			// PhoenixSQL.g:62:8: 'full'
			{
			match("full"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "FULL"

	// $ANTLR start "GROUP"
	public final void mGROUP() throws RecognitionException {
		try {
			int _type = GROUP;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:63:7: ( 'group' )
			// PhoenixSQL.g:63:9: 'group'
			{
			match("group"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "GROUP"

	// $ANTLR start "HAVING"
	public final void mHAVING() throws RecognitionException {
		try {
			int _type = HAVING;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:64:8: ( 'having' )
			// PhoenixSQL.g:64:10: 'having'
			{
			match("having"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "HAVING"

	// $ANTLR start "IF"
	public final void mIF() throws RecognitionException {
		try {
			int _type = IF;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:65:4: ( 'if' )
			// PhoenixSQL.g:65:6: 'if'
			{
			match("if"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "IF"

	// $ANTLR start "ILIKE"
	public final void mILIKE() throws RecognitionException {
		try {
			int _type = ILIKE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:66:7: ( 'ilike' )
			// PhoenixSQL.g:66:9: 'ilike'
			{
			match("ilike"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ILIKE"

	// $ANTLR start "IN"
	public final void mIN() throws RecognitionException {
		try {
			int _type = IN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:67:4: ( 'in' )
			// PhoenixSQL.g:67:6: 'in'
			{
			match("in"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "IN"

	// $ANTLR start "INCLUDE"
	public final void mINCLUDE() throws RecognitionException {
		try {
			int _type = INCLUDE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:68:9: ( 'include' )
			// PhoenixSQL.g:68:11: 'include'
			{
			match("include"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "INCLUDE"

	// $ANTLR start "INCREMENT"
	public final void mINCREMENT() throws RecognitionException {
		try {
			int _type = INCREMENT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:69:11: ( 'increment' )
			// PhoenixSQL.g:69:13: 'increment'
			{
			match("increment"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "INCREMENT"

	// $ANTLR start "INDEX"
	public final void mINDEX() throws RecognitionException {
		try {
			int _type = INDEX;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:70:7: ( 'index' )
			// PhoenixSQL.g:70:9: 'index'
			{
			match("index"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "INDEX"

	// $ANTLR start "INNER"
	public final void mINNER() throws RecognitionException {
		try {
			int _type = INNER;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:71:7: ( 'inner' )
			// PhoenixSQL.g:71:9: 'inner'
			{
			match("inner"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "INNER"

	// $ANTLR start "INTO"
	public final void mINTO() throws RecognitionException {
		try {
			int _type = INTO;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:72:6: ( 'into' )
			// PhoenixSQL.g:72:8: 'into'
			{
			match("into"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "INTO"

	// $ANTLR start "IS"
	public final void mIS() throws RecognitionException {
		try {
			int _type = IS;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:73:4: ( 'is' )
			// PhoenixSQL.g:73:6: 'is'
			{
			match("is"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "IS"

	// $ANTLR start "JOIN"
	public final void mJOIN() throws RecognitionException {
		try {
			int _type = JOIN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:74:6: ( 'join' )
			// PhoenixSQL.g:74:8: 'join'
			{
			match("join"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "JOIN"

	// $ANTLR start "KEY"
	public final void mKEY() throws RecognitionException {
		try {
			int _type = KEY;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:75:5: ( 'key' )
			// PhoenixSQL.g:75:7: 'key'
			{
			match("key"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "KEY"

	// $ANTLR start "LAST"
	public final void mLAST() throws RecognitionException {
		try {
			int _type = LAST;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:76:6: ( 'last' )
			// PhoenixSQL.g:76:8: 'last'
			{
			match("last"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "LAST"

	// $ANTLR start "LEFT"
	public final void mLEFT() throws RecognitionException {
		try {
			int _type = LEFT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:77:6: ( 'left' )
			// PhoenixSQL.g:77:8: 'left'
			{
			match("left"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "LEFT"

	// $ANTLR start "LIKE"
	public final void mLIKE() throws RecognitionException {
		try {
			int _type = LIKE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:78:6: ( 'like' )
			// PhoenixSQL.g:78:8: 'like'
			{
			match("like"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "LIKE"

	// $ANTLR start "LIMIT"
	public final void mLIMIT() throws RecognitionException {
		try {
			int _type = LIMIT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:79:7: ( 'limit' )
			// PhoenixSQL.g:79:9: 'limit'
			{
			match("limit"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "LIMIT"

	// $ANTLR start "LOCAL"
	public final void mLOCAL() throws RecognitionException {
		try {
			int _type = LOCAL;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:80:7: ( 'local' )
			// PhoenixSQL.g:80:9: 'local'
			{
			match("local"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "LOCAL"

	// $ANTLR start "MAXVALUE"
	public final void mMAXVALUE() throws RecognitionException {
		try {
			int _type = MAXVALUE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:81:10: ( 'maxvalue' )
			// PhoenixSQL.g:81:12: 'maxvalue'
			{
			match("maxvalue"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "MAXVALUE"

	// $ANTLR start "MINVALUE"
	public final void mMINVALUE() throws RecognitionException {
		try {
			int _type = MINVALUE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:82:10: ( 'minvalue' )
			// PhoenixSQL.g:82:12: 'minvalue'
			{
			match("minvalue"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "MINVALUE"

	// $ANTLR start "NEXT"
	public final void mNEXT() throws RecognitionException {
		try {
			int _type = NEXT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:83:6: ( 'next' )
			// PhoenixSQL.g:83:8: 'next'
			{
			match("next"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "NEXT"

	// $ANTLR start "NOT"
	public final void mNOT() throws RecognitionException {
		try {
			int _type = NOT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:84:5: ( 'not' )
			// PhoenixSQL.g:84:7: 'not'
			{
			match("not"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "NOT"

	// $ANTLR start "NULL"
	public final void mNULL() throws RecognitionException {
		try {
			int _type = NULL;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:85:6: ( 'null' )
			// PhoenixSQL.g:85:8: 'null'
			{
			match("null"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "NULL"

	// $ANTLR start "NULLS"
	public final void mNULLS() throws RecognitionException {
		try {
			int _type = NULLS;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:86:7: ( 'nulls' )
			// PhoenixSQL.g:86:9: 'nulls'
			{
			match("nulls"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "NULLS"

	// $ANTLR start "ON"
	public final void mON() throws RecognitionException {
		try {
			int _type = ON;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:87:4: ( 'on' )
			// PhoenixSQL.g:87:6: 'on'
			{
			match("on"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ON"

	// $ANTLR start "OR"
	public final void mOR() throws RecognitionException {
		try {
			int _type = OR;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:88:4: ( 'or' )
			// PhoenixSQL.g:88:6: 'or'
			{
			match("or"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "OR"

	// $ANTLR start "ORDER"
	public final void mORDER() throws RecognitionException {
		try {
			int _type = ORDER;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:89:7: ( 'order' )
			// PhoenixSQL.g:89:9: 'order'
			{
			match("order"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ORDER"

	// $ANTLR start "OUTER"
	public final void mOUTER() throws RecognitionException {
		try {
			int _type = OUTER;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:90:7: ( 'outer' )
			// PhoenixSQL.g:90:9: 'outer'
			{
			match("outer"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "OUTER"

	// $ANTLR start "PRIMARY"
	public final void mPRIMARY() throws RecognitionException {
		try {
			int _type = PRIMARY;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:91:9: ( 'primary' )
			// PhoenixSQL.g:91:11: 'primary'
			{
			match("primary"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "PRIMARY"

	// $ANTLR start "REBUILD"
	public final void mREBUILD() throws RecognitionException {
		try {
			int _type = REBUILD;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:92:9: ( 'rebuild' )
			// PhoenixSQL.g:92:11: 'rebuild'
			{
			match("rebuild"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "REBUILD"

	// $ANTLR start "RIGHT"
	public final void mRIGHT() throws RecognitionException {
		try {
			int _type = RIGHT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:93:7: ( 'right' )
			// PhoenixSQL.g:93:9: 'right'
			{
			match("right"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "RIGHT"

	// $ANTLR start "SELECT"
	public final void mSELECT() throws RecognitionException {
		try {
			int _type = SELECT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:94:8: ( 'select' )
			// PhoenixSQL.g:94:10: 'select'
			{
			match("select"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "SELECT"

	// $ANTLR start "SEQUENCE"
	public final void mSEQUENCE() throws RecognitionException {
		try {
			int _type = SEQUENCE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:95:10: ( 'sequence' )
			// PhoenixSQL.g:95:12: 'sequence'
			{
			match("sequence"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "SEQUENCE"

	// $ANTLR start "SET"
	public final void mSET() throws RecognitionException {
		try {
			int _type = SET;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:96:5: ( 'set' )
			// PhoenixSQL.g:96:7: 'set'
			{
			match("set"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "SET"

	// $ANTLR start "SOME"
	public final void mSOME() throws RecognitionException {
		try {
			int _type = SOME;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:97:6: ( 'some' )
			// PhoenixSQL.g:97:8: 'some'
			{
			match("some"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "SOME"

	// $ANTLR start "SPLIT"
	public final void mSPLIT() throws RecognitionException {
		try {
			int _type = SPLIT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:98:7: ( 'split' )
			// PhoenixSQL.g:98:9: 'split'
			{
			match("split"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "SPLIT"

	// $ANTLR start "START"
	public final void mSTART() throws RecognitionException {
		try {
			int _type = START;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:99:7: ( 'start' )
			// PhoenixSQL.g:99:9: 'start'
			{
			match("start"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "START"

	// $ANTLR start "STATISTICS"
	public final void mSTATISTICS() throws RecognitionException {
		try {
			int _type = STATISTICS;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:100:12: ( 'statistics' )
			// PhoenixSQL.g:100:14: 'statistics'
			{
			match("statistics"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "STATISTICS"

	// $ANTLR start "TABLE"
	public final void mTABLE() throws RecognitionException {
		try {
			int _type = TABLE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:101:7: ( 'table' )
			// PhoenixSQL.g:101:9: 'table'
			{
			match("table"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "TABLE"

	// $ANTLR start "TABLES"
	public final void mTABLES() throws RecognitionException {
		try {
			int _type = TABLES;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:102:8: ( 'tables' )
			// PhoenixSQL.g:102:10: 'tables'
			{
			match("tables"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "TABLES"

	// $ANTLR start "THEN"
	public final void mTHEN() throws RecognitionException {
		try {
			int _type = THEN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:103:6: ( 'then' )
			// PhoenixSQL.g:103:8: 'then'
			{
			match("then"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "THEN"

	// $ANTLR start "TRUE"
	public final void mTRUE() throws RecognitionException {
		try {
			int _type = TRUE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:104:6: ( 'true' )
			// PhoenixSQL.g:104:8: 'true'
			{
			match("true"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "TRUE"

	// $ANTLR start "UNUSABLE"
	public final void mUNUSABLE() throws RecognitionException {
		try {
			int _type = UNUSABLE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:105:10: ( 'unusable' )
			// PhoenixSQL.g:105:12: 'unusable'
			{
			match("unusable"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "UNUSABLE"

	// $ANTLR start "UPDATE"
	public final void mUPDATE() throws RecognitionException {
		try {
			int _type = UPDATE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:106:8: ( 'update' )
			// PhoenixSQL.g:106:10: 'update'
			{
			match("update"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "UPDATE"

	// $ANTLR start "UPSERT"
	public final void mUPSERT() throws RecognitionException {
		try {
			int _type = UPSERT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:107:8: ( 'upsert' )
			// PhoenixSQL.g:107:10: 'upsert'
			{
			match("upsert"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "UPSERT"

	// $ANTLR start "USABLE"
	public final void mUSABLE() throws RecognitionException {
		try {
			int _type = USABLE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:108:8: ( 'usable' )
			// PhoenixSQL.g:108:10: 'usable'
			{
			match("usable"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "USABLE"

	// $ANTLR start "VALUE"
	public final void mVALUE() throws RecognitionException {
		try {
			int _type = VALUE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:109:7: ( 'value' )
			// PhoenixSQL.g:109:9: 'value'
			{
			match("value"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "VALUE"

	// $ANTLR start "VALUES"
	public final void mVALUES() throws RecognitionException {
		try {
			int _type = VALUES;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:110:8: ( 'values' )
			// PhoenixSQL.g:110:10: 'values'
			{
			match("values"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "VALUES"

	// $ANTLR start "VIEW"
	public final void mVIEW() throws RecognitionException {
		try {
			int _type = VIEW;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:111:6: ( 'view' )
			// PhoenixSQL.g:111:8: 'view'
			{
			match("view"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "VIEW"

	// $ANTLR start "WHEN"
	public final void mWHEN() throws RecognitionException {
		try {
			int _type = WHEN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:112:6: ( 'when' )
			// PhoenixSQL.g:112:8: 'when'
			{
			match("when"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "WHEN"

	// $ANTLR start "WHERE"
	public final void mWHERE() throws RecognitionException {
		try {
			int _type = WHERE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:113:7: ( 'where' )
			// PhoenixSQL.g:113:9: 'where'
			{
			match("where"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "WHERE"

	// $ANTLR start "WITH"
	public final void mWITH() throws RecognitionException {
		try {
			int _type = WITH;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:114:6: ( 'with' )
			// PhoenixSQL.g:114:8: 'with'
			{
			match("with"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "WITH"

	// $ANTLR start "WITHIN"
	public final void mWITHIN() throws RecognitionException {
		try {
			int _type = WITHIN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:115:8: ( 'within' )
			// PhoenixSQL.g:115:10: 'within'
			{
			match("within"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "WITHIN"

	// $ANTLR start "HINT_START"
	public final void mHINT_START() throws RecognitionException {
		try {
			int _type = HINT_START;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:944:11: ( '/*+' )
			// PhoenixSQL.g:944:13: '/*+'
			{
			match("/*+"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "HINT_START"

	// $ANTLR start "COMMENT_START"
	public final void mCOMMENT_START() throws RecognitionException {
		try {
			int _type = COMMENT_START;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:945:14: ( '/*' )
			// PhoenixSQL.g:945:16: '/*'
			{
			match("/*"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "COMMENT_START"

	// $ANTLR start "COMMENT_AND_HINT_END"
	public final void mCOMMENT_AND_HINT_END() throws RecognitionException {
		try {
			int _type = COMMENT_AND_HINT_END;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:946:21: ( '*/' )
			// PhoenixSQL.g:946:23: '*/'
			{
			match("*/"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "COMMENT_AND_HINT_END"

	// $ANTLR start "SL_COMMENT1"
	public final void mSL_COMMENT1() throws RecognitionException {
		try {
			int _type = SL_COMMENT1;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:947:12: ( '//' )
			// PhoenixSQL.g:947:14: '//'
			{
			match("//"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "SL_COMMENT1"

	// $ANTLR start "SL_COMMENT2"
	public final void mSL_COMMENT2() throws RecognitionException {
		try {
			int _type = SL_COMMENT2;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:948:12: ( '--' )
			// PhoenixSQL.g:948:14: '--'
			{
			match("--"); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "SL_COMMENT2"

	// $ANTLR start "BIND_NAME"
	public final void mBIND_NAME() throws RecognitionException {
		try {
			int _type = BIND_NAME;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:952:5: ( COLON ( DIGIT )+ )
			// PhoenixSQL.g:952:7: COLON ( DIGIT )+
			{
			mCOLON(); 

			// PhoenixSQL.g:952:13: ( DIGIT )+
			int cnt1=0;
			loop1:
			while (true) {
				int alt1=2;
				int LA1_0 = input.LA(1);
				if ( ((LA1_0 >= '0' && LA1_0 <= '9')) ) {
					alt1=1;
				}

				switch (alt1) {
				case 1 :
					// PhoenixSQL.g:
					{
					if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
						input.consume();
					}
					else {
						MismatchedSetException mse = new MismatchedSetException(null,input);
						recover(mse);
						throw mse;
					}
					}
					break;

				default :
					if ( cnt1 >= 1 ) break loop1;
					EarlyExitException eee = new EarlyExitException(1, input);
					throw eee;
				}
				cnt1++;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "BIND_NAME"

	// $ANTLR start "NAME"
	public final void mNAME() throws RecognitionException {
		try {
			int _type = NAME;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:957:5: ( LETTER ( FIELDCHAR )* | '\\\"' ( DBL_QUOTE_CHAR )* '\\\"' )
			int alt4=2;
			int LA4_0 = input.LA(1);
			if ( ((LA4_0 >= 'A' && LA4_0 <= 'Z')||(LA4_0 >= 'a' && LA4_0 <= 'z')) ) {
				alt4=1;
			}
			else if ( (LA4_0=='\"') ) {
				alt4=2;
			}

			else {
				NoViableAltException nvae =
					new NoViableAltException("", 4, 0, input);
				throw nvae;
			}

			switch (alt4) {
				case 1 :
					// PhoenixSQL.g:957:10: LETTER ( FIELDCHAR )*
					{
					mLETTER(); 

					// PhoenixSQL.g:957:17: ( FIELDCHAR )*
					loop2:
					while (true) {
						int alt2=2;
						int LA2_0 = input.LA(1);
						if ( ((LA2_0 >= '0' && LA2_0 <= '9')||(LA2_0 >= 'A' && LA2_0 <= 'Z')||LA2_0=='_'||(LA2_0 >= 'a' && LA2_0 <= 'z')||(LA2_0 >= '\u0080' && LA2_0 <= '\uFFFE')) ) {
							alt2=1;
						}

						switch (alt2) {
						case 1 :
							// PhoenixSQL.g:
							{
							if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z')||(input.LA(1) >= '\u0080' && input.LA(1) <= '\uFFFE') ) {
								input.consume();
							}
							else {
								MismatchedSetException mse = new MismatchedSetException(null,input);
								recover(mse);
								throw mse;
							}
							}
							break;

						default :
							break loop2;
						}
					}

					}
					break;
				case 2 :
					// PhoenixSQL.g:958:10: '\\\"' ( DBL_QUOTE_CHAR )* '\\\"'
					{
					match('\"'); 
					// PhoenixSQL.g:958:15: ( DBL_QUOTE_CHAR )*
					loop3:
					while (true) {
						int alt3=2;
						int LA3_0 = input.LA(1);
						if ( ((LA3_0 >= '\u0000' && LA3_0 <= '!')||(LA3_0 >= '#' && LA3_0 <= '\uFFFF')) ) {
							alt3=1;
						}

						switch (alt3) {
						case 1 :
							// PhoenixSQL.g:958:16: DBL_QUOTE_CHAR
							{
							mDBL_QUOTE_CHAR(); 

							}
							break;

						default :
							break loop3;
						}
					}

					match('\"'); 
					}
					break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "NAME"

	// $ANTLR start "NUMBER"
	public final void mNUMBER() throws RecognitionException {
		try {
			int _type = NUMBER;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:963:5: ( POSINTEGER )
			// PhoenixSQL.g:963:9: POSINTEGER
			{
			mPOSINTEGER(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "NUMBER"

	// $ANTLR start "LONG"
	public final void mLONG() throws RecognitionException {
		try {
			int _type = LONG;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:967:5: ( POSINTEGER ( 'L' | 'l' ) )
			// PhoenixSQL.g:967:9: POSINTEGER ( 'L' | 'l' )
			{
			mPOSINTEGER(); 

			if ( input.LA(1)=='L'||input.LA(1)=='l' ) {
				input.consume();
			}
			else {
				MismatchedSetException mse = new MismatchedSetException(null,input);
				recover(mse);
				throw mse;
			}
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "LONG"

	// $ANTLR start "DECIMAL"
	public final void mDECIMAL() throws RecognitionException {
		try {
			int _type = DECIMAL;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:972:5: ( ( POSINTEGER )? '.' POSINTEGER )
			// PhoenixSQL.g:972:9: ( POSINTEGER )? '.' POSINTEGER
			{
			// PhoenixSQL.g:972:9: ( POSINTEGER )?
			int alt5=2;
			int LA5_0 = input.LA(1);
			if ( ((LA5_0 >= '0' && LA5_0 <= '9')) ) {
				alt5=1;
			}
			switch (alt5) {
				case 1 :
					// PhoenixSQL.g:972:9: POSINTEGER
					{
					mPOSINTEGER(); 

					}
					break;

			}

			match('.'); 
			mPOSINTEGER(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DECIMAL"

	// $ANTLR start "DOUBLE"
	public final void mDOUBLE() throws RecognitionException {
		try {
			int _type = DOUBLE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:976:5: ( DECIMAL ( 'D' | 'd' ) )
			// PhoenixSQL.g:976:9: DECIMAL ( 'D' | 'd' )
			{
			mDECIMAL(); 

			if ( input.LA(1)=='D'||input.LA(1)=='d' ) {
				input.consume();
			}
			else {
				MismatchedSetException mse = new MismatchedSetException(null,input);
				recover(mse);
				throw mse;
			}
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DOUBLE"

	// $ANTLR start "DOUBLE_QUOTE"
	public final void mDOUBLE_QUOTE() throws RecognitionException {
		try {
			int _type = DOUBLE_QUOTE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:980:5: ( '\"' )
			// PhoenixSQL.g:980:9: '\"'
			{
			match('\"'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DOUBLE_QUOTE"

	// $ANTLR start "EQ"
	public final void mEQ() throws RecognitionException {
		try {
			int _type = EQ;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:984:5: ( '=' )
			// PhoenixSQL.g:984:9: '='
			{
			match('='); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "EQ"

	// $ANTLR start "LT"
	public final void mLT() throws RecognitionException {
		try {
			int _type = LT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:988:5: ( '<' )
			// PhoenixSQL.g:988:9: '<'
			{
			match('<'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "LT"

	// $ANTLR start "GT"
	public final void mGT() throws RecognitionException {
		try {
			int _type = GT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:992:5: ( '>' )
			// PhoenixSQL.g:992:9: '>'
			{
			match('>'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "GT"

	// $ANTLR start "DOUBLE_EQ"
	public final void mDOUBLE_EQ() throws RecognitionException {
		try {
			int _type = DOUBLE_EQ;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:996:5: ( '=' '=' )
			// PhoenixSQL.g:996:9: '=' '='
			{
			match('='); 
			match('='); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DOUBLE_EQ"

	// $ANTLR start "NOEQ1"
	public final void mNOEQ1() throws RecognitionException {
		try {
			int _type = NOEQ1;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1000:5: ( '!' '=' )
			// PhoenixSQL.g:1000:9: '!' '='
			{
			match('!'); 
			match('='); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "NOEQ1"

	// $ANTLR start "NOEQ2"
	public final void mNOEQ2() throws RecognitionException {
		try {
			int _type = NOEQ2;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1004:5: ( '<' '>' )
			// PhoenixSQL.g:1004:9: '<' '>'
			{
			match('<'); 
			match('>'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "NOEQ2"

	// $ANTLR start "CONCAT"
	public final void mCONCAT() throws RecognitionException {
		try {
			int _type = CONCAT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1008:5: ( '|' '|' )
			// PhoenixSQL.g:1008:9: '|' '|'
			{
			match('|'); 
			match('|'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "CONCAT"

	// $ANTLR start "COMMA"
	public final void mCOMMA() throws RecognitionException {
		try {
			int _type = COMMA;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1012:5: ( ',' )
			// PhoenixSQL.g:1012:9: ','
			{
			match(','); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "COMMA"

	// $ANTLR start "LPAREN"
	public final void mLPAREN() throws RecognitionException {
		try {
			int _type = LPAREN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1016:5: ( '(' )
			// PhoenixSQL.g:1016:9: '('
			{
			match('('); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "LPAREN"

	// $ANTLR start "RPAREN"
	public final void mRPAREN() throws RecognitionException {
		try {
			int _type = RPAREN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1020:5: ( ')' )
			// PhoenixSQL.g:1020:9: ')'
			{
			match(')'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "RPAREN"

	// $ANTLR start "SEMICOLON"
	public final void mSEMICOLON() throws RecognitionException {
		try {
			int _type = SEMICOLON;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1024:5: ( ';' )
			// PhoenixSQL.g:1024:9: ';'
			{
			match(';'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "SEMICOLON"

	// $ANTLR start "COLON"
	public final void mCOLON() throws RecognitionException {
		try {
			int _type = COLON;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1028:5: ( ':' )
			// PhoenixSQL.g:1028:9: ':'
			{
			match(':'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "COLON"

	// $ANTLR start "QUESTION"
	public final void mQUESTION() throws RecognitionException {
		try {
			int _type = QUESTION;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1032:5: ( '?' )
			// PhoenixSQL.g:1032:9: '?'
			{
			match('?'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "QUESTION"

	// $ANTLR start "LSQUARE"
	public final void mLSQUARE() throws RecognitionException {
		try {
			int _type = LSQUARE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1036:5: ( '[' )
			// PhoenixSQL.g:1036:9: '['
			{
			match('['); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "LSQUARE"

	// $ANTLR start "RSQUARE"
	public final void mRSQUARE() throws RecognitionException {
		try {
			int _type = RSQUARE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1040:5: ( ']' )
			// PhoenixSQL.g:1040:9: ']'
			{
			match(']'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "RSQUARE"

	// $ANTLR start "LCURLY"
	public final void mLCURLY() throws RecognitionException {
		try {
			int _type = LCURLY;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1044:5: ( '{' )
			// PhoenixSQL.g:1044:9: '{'
			{
			match('{'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "LCURLY"

	// $ANTLR start "RCURLY"
	public final void mRCURLY() throws RecognitionException {
		try {
			int _type = RCURLY;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1048:5: ( '}' )
			// PhoenixSQL.g:1048:9: '}'
			{
			match('}'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "RCURLY"

	// $ANTLR start "AT"
	public final void mAT() throws RecognitionException {
		try {
			int _type = AT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1052:5: ( '@' )
			// PhoenixSQL.g:1052:9: '@'
			{
			match('@'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "AT"

	// $ANTLR start "TILDE"
	public final void mTILDE() throws RecognitionException {
		try {
			int _type = TILDE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1056:5: ( '~' )
			// PhoenixSQL.g:1056:9: '~'
			{
			match('~'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "TILDE"

	// $ANTLR start "PLUS"
	public final void mPLUS() throws RecognitionException {
		try {
			int _type = PLUS;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1060:5: ( '+' )
			// PhoenixSQL.g:1060:9: '+'
			{
			match('+'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "PLUS"

	// $ANTLR start "MINUS"
	public final void mMINUS() throws RecognitionException {
		try {
			int _type = MINUS;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1064:5: ( '-' )
			// PhoenixSQL.g:1064:9: '-'
			{
			match('-'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "MINUS"

	// $ANTLR start "ASTERISK"
	public final void mASTERISK() throws RecognitionException {
		try {
			int _type = ASTERISK;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1068:5: ( '*' )
			// PhoenixSQL.g:1068:9: '*'
			{
			match('*'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ASTERISK"

	// $ANTLR start "DIVIDE"
	public final void mDIVIDE() throws RecognitionException {
		try {
			int _type = DIVIDE;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1072:5: ( '/' )
			// PhoenixSQL.g:1072:9: '/'
			{
			match('/'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DIVIDE"

	// $ANTLR start "PERCENT"
	public final void mPERCENT() throws RecognitionException {
		try {
			int _type = PERCENT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1076:5: ( '%' )
			// PhoenixSQL.g:1076:9: '%'
			{
			match('%'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "PERCENT"

	// $ANTLR start "OUTER_JOIN"
	public final void mOUTER_JOIN() throws RecognitionException {
		try {
			int _type = OUTER_JOIN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1080:5: ( '(' '+' ')' )
			// PhoenixSQL.g:1080:7: '(' '+' ')'
			{
			match('('); 
			match('+'); 
			match(')'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "OUTER_JOIN"

	// $ANTLR start "FIELDCHAR"
	public final void mFIELDCHAR() throws RecognitionException {
		try {
			// PhoenixSQL.g:1086:5: ( LETTER | DIGIT | '_' | '\\u0080' .. '\\ufffe' )
			// PhoenixSQL.g:
			{
			if ( (input.LA(1) >= '0' && input.LA(1) <= '9')||(input.LA(1) >= 'A' && input.LA(1) <= 'Z')||input.LA(1)=='_'||(input.LA(1) >= 'a' && input.LA(1) <= 'z')||(input.LA(1) >= '\u0080' && input.LA(1) <= '\uFFFE') ) {
				input.consume();
			}
			else {
				MismatchedSetException mse = new MismatchedSetException(null,input);
				recover(mse);
				throw mse;
			}
			}

		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "FIELDCHAR"

	// $ANTLR start "LETTER"
	public final void mLETTER() throws RecognitionException {
		try {
			// PhoenixSQL.g:1095:5: ( 'a' .. 'z' | 'A' .. 'Z' )
			// PhoenixSQL.g:
			{
			if ( (input.LA(1) >= 'A' && input.LA(1) <= 'Z')||(input.LA(1) >= 'a' && input.LA(1) <= 'z') ) {
				input.consume();
			}
			else {
				MismatchedSetException mse = new MismatchedSetException(null,input);
				recover(mse);
				throw mse;
			}
			}

		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "LETTER"

	// $ANTLR start "POSINTEGER"
	public final void mPOSINTEGER() throws RecognitionException {
		try {
			// PhoenixSQL.g:1101:5: ( ( DIGIT )+ )
			// PhoenixSQL.g:1101:9: ( DIGIT )+
			{
			// PhoenixSQL.g:1101:9: ( DIGIT )+
			int cnt6=0;
			loop6:
			while (true) {
				int alt6=2;
				int LA6_0 = input.LA(1);
				if ( ((LA6_0 >= '0' && LA6_0 <= '9')) ) {
					alt6=1;
				}

				switch (alt6) {
				case 1 :
					// PhoenixSQL.g:
					{
					if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
						input.consume();
					}
					else {
						MismatchedSetException mse = new MismatchedSetException(null,input);
						recover(mse);
						throw mse;
					}
					}
					break;

				default :
					if ( cnt6 >= 1 ) break loop6;
					EarlyExitException eee = new EarlyExitException(6, input);
					throw eee;
				}
				cnt6++;
			}

			}

		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "POSINTEGER"

	// $ANTLR start "DIGIT"
	public final void mDIGIT() throws RecognitionException {
		try {
			// PhoenixSQL.g:1106:5: ( '0' .. '9' )
			// PhoenixSQL.g:
			{
			if ( (input.LA(1) >= '0' && input.LA(1) <= '9') ) {
				input.consume();
			}
			else {
				MismatchedSetException mse = new MismatchedSetException(null,input);
				recover(mse);
				throw mse;
			}
			}

		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DIGIT"

	// $ANTLR start "STRING_LITERAL"
	public final void mSTRING_LITERAL() throws RecognitionException {
		try {
			int _type = STRING_LITERAL;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			CommonToken t=null;

			 StringBuilder sb = new StringBuilder(); 
			// PhoenixSQL.g:1111:5: ( '\\'' (t= CHAR |t= CHAR_ESC )* '\\'' )
			// PhoenixSQL.g:1111:9: '\\'' (t= CHAR |t= CHAR_ESC )* '\\''
			{
			match('\''); 
			// PhoenixSQL.g:1112:5: (t= CHAR |t= CHAR_ESC )*
			loop7:
			while (true) {
				int alt7=3;
				int LA7_0 = input.LA(1);
				if ( (LA7_0=='\'') ) {
					int LA7_1 = input.LA(2);
					if ( (LA7_1=='\'') ) {
						alt7=2;
					}

				}
				else if ( ((LA7_0 >= '\u0000' && LA7_0 <= '&')||(LA7_0 >= '(' && LA7_0 <= '[')||(LA7_0 >= ']' && LA7_0 <= '\uFFFF')) ) {
					alt7=1;
				}
				else if ( (LA7_0=='\\') ) {
					alt7=2;
				}

				switch (alt7) {
				case 1 :
					// PhoenixSQL.g:1112:7: t= CHAR
					{
					int tStart1534 = getCharIndex();
					int tStartLine1534 = getLine();
					int tStartCharPos1534 = getCharPositionInLine();
					mCHAR(); 
					t = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, tStart1534, getCharIndex()-1);
					t.setLine(tStartLine1534);
					t.setCharPositionInLine(tStartCharPos1534);

					 sb.append(t.getText()); 
					}
					break;
				case 2 :
					// PhoenixSQL.g:1113:7: t= CHAR_ESC
					{
					int tStart1546 = getCharIndex();
					int tStartLine1546 = getLine();
					int tStartCharPos1546 = getCharPositionInLine();
					mCHAR_ESC(); 
					t = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, tStart1546, getCharIndex()-1);
					t.setLine(tStartLine1546);
					t.setCharPositionInLine(tStartCharPos1546);

					 sb.append(getText()); 
					}
					break;

				default :
					break loop7;
				}
			}

			match('\''); 
			 setText(sb.toString()); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "STRING_LITERAL"

	// $ANTLR start "CHAR"
	public final void mCHAR() throws RecognitionException {
		try {
			// PhoenixSQL.g:1120:5: ( (~ ( '\\'' | '\\\\' ) )+ )
			// PhoenixSQL.g:1120:9: (~ ( '\\'' | '\\\\' ) )+
			{
			// PhoenixSQL.g:1120:9: (~ ( '\\'' | '\\\\' ) )+
			int cnt8=0;
			loop8:
			while (true) {
				int alt8=2;
				int LA8_0 = input.LA(1);
				if ( ((LA8_0 >= '\u0000' && LA8_0 <= '&')||(LA8_0 >= '(' && LA8_0 <= '[')||(LA8_0 >= ']' && LA8_0 <= '\uFFFF')) ) {
					alt8=1;
				}

				switch (alt8) {
				case 1 :
					// PhoenixSQL.g:
					{
					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '&')||(input.LA(1) >= '(' && input.LA(1) <= '[')||(input.LA(1) >= ']' && input.LA(1) <= '\uFFFF') ) {
						input.consume();
					}
					else {
						MismatchedSetException mse = new MismatchedSetException(null,input);
						recover(mse);
						throw mse;
					}
					}
					break;

				default :
					if ( cnt8 >= 1 ) break loop8;
					EarlyExitException eee = new EarlyExitException(8, input);
					throw eee;
				}
				cnt8++;
			}

			}

		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "CHAR"

	// $ANTLR start "DBL_QUOTE_CHAR"
	public final void mDBL_QUOTE_CHAR() throws RecognitionException {
		try {
			// PhoenixSQL.g:1125:5: ( (~ ( '\\\"' ) )+ )
			// PhoenixSQL.g:1125:9: (~ ( '\\\"' ) )+
			{
			// PhoenixSQL.g:1125:9: (~ ( '\\\"' ) )+
			int cnt9=0;
			loop9:
			while (true) {
				int alt9=2;
				int LA9_0 = input.LA(1);
				if ( ((LA9_0 >= '\u0000' && LA9_0 <= '!')||(LA9_0 >= '#' && LA9_0 <= '\uFFFF')) ) {
					alt9=1;
				}

				switch (alt9) {
				case 1 :
					// PhoenixSQL.g:
					{
					if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '!')||(input.LA(1) >= '#' && input.LA(1) <= '\uFFFF') ) {
						input.consume();
					}
					else {
						MismatchedSetException mse = new MismatchedSetException(null,input);
						recover(mse);
						throw mse;
					}
					}
					break;

				default :
					if ( cnt9 >= 1 ) break loop9;
					EarlyExitException eee = new EarlyExitException(9, input);
					throw eee;
				}
				cnt9++;
			}

			}

		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DBL_QUOTE_CHAR"

	// $ANTLR start "CHAR_ESC"
	public final void mCHAR_ESC() throws RecognitionException {
		try {
			// PhoenixSQL.g:1131:5: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\\\"' | '\\'' | '\\\\' | '_' | '%' ) | '\\'\\'' )
			int alt11=2;
			int LA11_0 = input.LA(1);
			if ( (LA11_0=='\\') ) {
				alt11=1;
			}
			else if ( (LA11_0=='\'') ) {
				alt11=2;
			}

			else {
				NoViableAltException nvae =
					new NoViableAltException("", 11, 0, input);
				throw nvae;
			}

			switch (alt11) {
				case 1 :
					// PhoenixSQL.g:1131:9: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\\\"' | '\\'' | '\\\\' | '_' | '%' )
					{
					match('\\'); 
					// PhoenixSQL.g:1132:9: ( 'n' | 'r' | 't' | 'b' | 'f' | '\\\"' | '\\'' | '\\\\' | '_' | '%' )
					int alt10=10;
					switch ( input.LA(1) ) {
					case 'n':
						{
						alt10=1;
						}
						break;
					case 'r':
						{
						alt10=2;
						}
						break;
					case 't':
						{
						alt10=3;
						}
						break;
					case 'b':
						{
						alt10=4;
						}
						break;
					case 'f':
						{
						alt10=5;
						}
						break;
					case '\"':
						{
						alt10=6;
						}
						break;
					case '\'':
						{
						alt10=7;
						}
						break;
					case '\\':
						{
						alt10=8;
						}
						break;
					case '_':
						{
						alt10=9;
						}
						break;
					case '%':
						{
						alt10=10;
						}
						break;
					default:
						NoViableAltException nvae =
							new NoViableAltException("", 10, 0, input);
						throw nvae;
					}
					switch (alt10) {
						case 1 :
							// PhoenixSQL.g:1132:11: 'n'
							{
							match('n'); 
							 setText("\n"); 
							}
							break;
						case 2 :
							// PhoenixSQL.g:1133:11: 'r'
							{
							match('r'); 
							 setText("\r"); 
							}
							break;
						case 3 :
							// PhoenixSQL.g:1134:11: 't'
							{
							match('t'); 
							 setText("\t"); 
							}
							break;
						case 4 :
							// PhoenixSQL.g:1135:11: 'b'
							{
							match('b'); 
							 setText("\b"); 
							}
							break;
						case 5 :
							// PhoenixSQL.g:1136:11: 'f'
							{
							match('f'); 
							 setText("\f"); 
							}
							break;
						case 6 :
							// PhoenixSQL.g:1137:11: '\\\"'
							{
							match('\"'); 
							 setText("\""); 
							}
							break;
						case 7 :
							// PhoenixSQL.g:1138:11: '\\''
							{
							match('\''); 
							 setText("\'"); 
							}
							break;
						case 8 :
							// PhoenixSQL.g:1139:11: '\\\\'
							{
							match('\\'); 
							 setText("\\"); 
							}
							break;
						case 9 :
							// PhoenixSQL.g:1140:11: '_'
							{
							match('_'); 
							 setText("\\_"); 
							}
							break;
						case 10 :
							// PhoenixSQL.g:1141:11: '%'
							{
							match('%'); 
							 setText("\\%"); 
							}
							break;

					}

					}
					break;
				case 2 :
					// PhoenixSQL.g:1143:9: '\\'\\''
					{
					match("''"); 

					 setText("\'"); 
					}
					break;

			}
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "CHAR_ESC"

	// $ANTLR start "WS"
	public final void mWS() throws RecognitionException {
		try {
			int _type = WS;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1147:5: ( ( ' ' | '\\t' ) )
			// PhoenixSQL.g:1147:9: ( ' ' | '\\t' )
			{
			if ( input.LA(1)=='\t'||input.LA(1)==' ' ) {
				input.consume();
			}
			else {
				MismatchedSetException mse = new MismatchedSetException(null,input);
				recover(mse);
				throw mse;
			}
			 _channel=HIDDEN; 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "WS"

	// $ANTLR start "EOL"
	public final void mEOL() throws RecognitionException {
		try {
			int _type = EOL;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1151:5: ( ( '\\r' | '\\n' ) )
			// PhoenixSQL.g:1151:8: ( '\\r' | '\\n' )
			{
			if ( input.LA(1)=='\n'||input.LA(1)=='\r' ) {
				input.consume();
			}
			else {
				MismatchedSetException mse = new MismatchedSetException(null,input);
				recover(mse);
				throw mse;
			}
			 skip(); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "EOL"

	// $ANTLR start "ML_HINT"
	public final void mML_HINT() throws RecognitionException {
		try {
			int _type = ML_HINT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			CommonToken h=null;
			int t;

			 StringBuilder sb = new StringBuilder(); 
			// PhoenixSQL.g:1158:5: (h= HINT_START ( options {greedy=false; } :t= . )* COMMENT_AND_HINT_END )
			// PhoenixSQL.g:1158:7: h= HINT_START ( options {greedy=false; } :t= . )* COMMENT_AND_HINT_END
			{
			int hStart1898 = getCharIndex();
			int hStartLine1898 = getLine();
			int hStartCharPos1898 = getCharPositionInLine();
			mHINT_START(); 
			h = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, hStart1898, getCharIndex()-1);
			h.setLine(hStartLine1898);
			h.setCharPositionInLine(hStartCharPos1898);

			// PhoenixSQL.g:1158:20: ( options {greedy=false; } :t= . )*
			loop12:
			while (true) {
				int alt12=2;
				int LA12_0 = input.LA(1);
				if ( (LA12_0=='*') ) {
					int LA12_1 = input.LA(2);
					if ( (LA12_1=='/') ) {
						alt12=2;
					}
					else if ( ((LA12_1 >= '\u0000' && LA12_1 <= '.')||(LA12_1 >= '0' && LA12_1 <= '\uFFFF')) ) {
						alt12=1;
					}

				}
				else if ( ((LA12_0 >= '\u0000' && LA12_0 <= ')')||(LA12_0 >= '+' && LA12_0 <= '\uFFFF')) ) {
					alt12=1;
				}

				switch (alt12) {
				case 1 :
					// PhoenixSQL.g:1158:48: t= .
					{
					t = input.LA(1);
					matchAny(); 
					}
					break;

				default :
					break loop12;
				}
			}

			 sb.append(getText()); 
			mCOMMENT_AND_HINT_END(); 

			 setText(sb.substring(h.getText().length())); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ML_HINT"

	// $ANTLR start "ML_COMMENT"
	public final void mML_COMMENT() throws RecognitionException {
		try {
			int _type = ML_COMMENT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1163:5: ( COMMENT_START (~ PLUS ) ( options {greedy=false; } : . )* COMMENT_AND_HINT_END )
			// PhoenixSQL.g:1163:7: COMMENT_START (~ PLUS ) ( options {greedy=false; } : . )* COMMENT_AND_HINT_END
			{
			mCOMMENT_START(); 

			if ( (input.LA(1) >= '\u0000' && input.LA(1) <= '*')||(input.LA(1) >= ',' && input.LA(1) <= '\uFFFF') ) {
				input.consume();
			}
			else {
				MismatchedSetException mse = new MismatchedSetException(null,input);
				recover(mse);
				throw mse;
			}
			// PhoenixSQL.g:1163:29: ( options {greedy=false; } : . )*
			loop13:
			while (true) {
				int alt13=2;
				int LA13_0 = input.LA(1);
				if ( (LA13_0=='*') ) {
					int LA13_1 = input.LA(2);
					if ( (LA13_1=='/') ) {
						alt13=2;
					}
					else if ( ((LA13_1 >= '\u0000' && LA13_1 <= '.')||(LA13_1 >= '0' && LA13_1 <= '\uFFFF')) ) {
						alt13=1;
					}

				}
				else if ( ((LA13_0 >= '\u0000' && LA13_0 <= ')')||(LA13_0 >= '+' && LA13_0 <= '\uFFFF')) ) {
					alt13=1;
				}

				switch (alt13) {
				case 1 :
					// PhoenixSQL.g:1163:57: .
					{
					matchAny(); 
					}
					break;

				default :
					break loop13;
				}
			}

			mCOMMENT_AND_HINT_END(); 

			 skip(); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "ML_COMMENT"

	// $ANTLR start "SL_COMMENT"
	public final void mSL_COMMENT() throws RecognitionException {
		try {
			int _type = SL_COMMENT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1168:5: ( ( SL_COMMENT1 | SL_COMMENT2 ) ( options {greedy=false; } : . )* EOL )
			// PhoenixSQL.g:1168:7: ( SL_COMMENT1 | SL_COMMENT2 ) ( options {greedy=false; } : . )* EOL
			{
			// PhoenixSQL.g:1168:7: ( SL_COMMENT1 | SL_COMMENT2 )
			int alt14=2;
			int LA14_0 = input.LA(1);
			if ( (LA14_0=='/') ) {
				alt14=1;
			}
			else if ( (LA14_0=='-') ) {
				alt14=2;
			}

			else {
				NoViableAltException nvae =
					new NoViableAltException("", 14, 0, input);
				throw nvae;
			}

			switch (alt14) {
				case 1 :
					// PhoenixSQL.g:1168:8: SL_COMMENT1
					{
					mSL_COMMENT1(); 

					}
					break;
				case 2 :
					// PhoenixSQL.g:1168:22: SL_COMMENT2
					{
					mSL_COMMENT2(); 

					}
					break;

			}

			// PhoenixSQL.g:1168:35: ( options {greedy=false; } : . )*
			loop15:
			while (true) {
				int alt15=2;
				int LA15_0 = input.LA(1);
				if ( (LA15_0=='\n'||LA15_0=='\r') ) {
					alt15=2;
				}
				else if ( ((LA15_0 >= '\u0000' && LA15_0 <= '\t')||(LA15_0 >= '\u000B' && LA15_0 <= '\f')||(LA15_0 >= '\u000E' && LA15_0 <= '\uFFFF')) ) {
					alt15=1;
				}

				switch (alt15) {
				case 1 :
					// PhoenixSQL.g:1168:63: .
					{
					matchAny(); 
					}
					break;

				default :
					break loop15;
				}
			}

			mEOL(); 

			 skip(); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "SL_COMMENT"

	// $ANTLR start "DOT"
	public final void mDOT() throws RecognitionException {
		try {
			int _type = DOT;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1173:5: ( '.' )
			// PhoenixSQL.g:1173:7: '.'
			{
			match('.'); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "DOT"

	// $ANTLR start "OTHER"
	public final void mOTHER() throws RecognitionException {
		try {
			int _type = OTHER;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// PhoenixSQL.g:1177:5: ( . )
			// PhoenixSQL.g:1177:7: .
			{
			matchAny(); 
			 if (true) // to prevent compile error
			              throw new RuntimeException("Unexpected char: '" + getText() + "'"); 
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}
	// $ANTLR end "OTHER"

	@Override
	public void mTokens() throws RecognitionException {
		// PhoenixSQL.g:1:8: ( ADD | ALL | ALTER | AND | ANY | ARRAY | AS | ASC | BETWEEN | BY | CACHE | CASCADE | CASE | CAST | COLUMN | COLUMNS | CONSTRAINT | CREATE | CURRENT | CYCLE | DELETE | DESC | DISABLE | DISTINCT | DROP | ELSE | END | EXISTS | EXPLAIN | FALSE | FIRST | FOR | FROM | FULL | GROUP | HAVING | IF | ILIKE | IN | INCLUDE | INCREMENT | INDEX | INNER | INTO | IS | JOIN | KEY | LAST | LEFT | LIKE | LIMIT | LOCAL | MAXVALUE | MINVALUE | NEXT | NOT | NULL | NULLS | ON | OR | ORDER | OUTER | PRIMARY | REBUILD | RIGHT | SELECT | SEQUENCE | SET | SOME | SPLIT | START | STATISTICS | TABLE | TABLES | THEN | TRUE | UNUSABLE | UPDATE | UPSERT | USABLE | VALUE | VALUES | VIEW | WHEN | WHERE | WITH | WITHIN | HINT_START | COMMENT_START | COMMENT_AND_HINT_END | SL_COMMENT1 | SL_COMMENT2 | BIND_NAME | NAME | NUMBER | LONG | DECIMAL | DOUBLE | DOUBLE_QUOTE | EQ | LT | GT | DOUBLE_EQ | NOEQ1 | NOEQ2 | CONCAT | COMMA | LPAREN | RPAREN | SEMICOLON | COLON | QUESTION | LSQUARE | RSQUARE | LCURLY | RCURLY | AT | TILDE | PLUS | MINUS | ASTERISK | DIVIDE | PERCENT | OUTER_JOIN | STRING_LITERAL | WS | EOL | ML_HINT | ML_COMMENT | SL_COMMENT | DOT | OTHER )
		int alt16=132;
		alt16 = dfa16.predict(input);
		switch (alt16) {
			case 1 :
				// PhoenixSQL.g:1:10: ADD
				{
				mADD(); 

				}
				break;
			case 2 :
				// PhoenixSQL.g:1:14: ALL
				{
				mALL(); 

				}
				break;
			case 3 :
				// PhoenixSQL.g:1:18: ALTER
				{
				mALTER(); 

				}
				break;
			case 4 :
				// PhoenixSQL.g:1:24: AND
				{
				mAND(); 

				}
				break;
			case 5 :
				// PhoenixSQL.g:1:28: ANY
				{
				mANY(); 

				}
				break;
			case 6 :
				// PhoenixSQL.g:1:32: ARRAY
				{
				mARRAY(); 

				}
				break;
			case 7 :
				// PhoenixSQL.g:1:38: AS
				{
				mAS(); 

				}
				break;
			case 8 :
				// PhoenixSQL.g:1:41: ASC
				{
				mASC(); 

				}
				break;
			case 9 :
				// PhoenixSQL.g:1:45: BETWEEN
				{
				mBETWEEN(); 

				}
				break;
			case 10 :
				// PhoenixSQL.g:1:53: BY
				{
				mBY(); 

				}
				break;
			case 11 :
				// PhoenixSQL.g:1:56: CACHE
				{
				mCACHE(); 

				}
				break;
			case 12 :
				// PhoenixSQL.g:1:62: CASCADE
				{
				mCASCADE(); 

				}
				break;
			case 13 :
				// PhoenixSQL.g:1:70: CASE
				{
				mCASE(); 

				}
				break;
			case 14 :
				// PhoenixSQL.g:1:75: CAST
				{
				mCAST(); 

				}
				break;
			case 15 :
				// PhoenixSQL.g:1:80: COLUMN
				{
				mCOLUMN(); 

				}
				break;
			case 16 :
				// PhoenixSQL.g:1:87: COLUMNS
				{
				mCOLUMNS(); 

				}
				break;
			case 17 :
				// PhoenixSQL.g:1:95: CONSTRAINT
				{
				mCONSTRAINT(); 

				}
				break;
			case 18 :
				// PhoenixSQL.g:1:106: CREATE
				{
				mCREATE(); 

				}
				break;
			case 19 :
				// PhoenixSQL.g:1:113: CURRENT
				{
				mCURRENT(); 

				}
				break;
			case 20 :
				// PhoenixSQL.g:1:121: CYCLE
				{
				mCYCLE(); 

				}
				break;
			case 21 :
				// PhoenixSQL.g:1:127: DELETE
				{
				mDELETE(); 

				}
				break;
			case 22 :
				// PhoenixSQL.g:1:134: DESC
				{
				mDESC(); 

				}
				break;
			case 23 :
				// PhoenixSQL.g:1:139: DISABLE
				{
				mDISABLE(); 

				}
				break;
			case 24 :
				// PhoenixSQL.g:1:147: DISTINCT
				{
				mDISTINCT(); 

				}
				break;
			case 25 :
				// PhoenixSQL.g:1:156: DROP
				{
				mDROP(); 

				}
				break;
			case 26 :
				// PhoenixSQL.g:1:161: ELSE
				{
				mELSE(); 

				}
				break;
			case 27 :
				// PhoenixSQL.g:1:166: END
				{
				mEND(); 

				}
				break;
			case 28 :
				// PhoenixSQL.g:1:170: EXISTS
				{
				mEXISTS(); 

				}
				break;
			case 29 :
				// PhoenixSQL.g:1:177: EXPLAIN
				{
				mEXPLAIN(); 

				}
				break;
			case 30 :
				// PhoenixSQL.g:1:185: FALSE
				{
				mFALSE(); 

				}
				break;
			case 31 :
				// PhoenixSQL.g:1:191: FIRST
				{
				mFIRST(); 

				}
				break;
			case 32 :
				// PhoenixSQL.g:1:197: FOR
				{
				mFOR(); 

				}
				break;
			case 33 :
				// PhoenixSQL.g:1:201: FROM
				{
				mFROM(); 

				}
				break;
			case 34 :
				// PhoenixSQL.g:1:206: FULL
				{
				mFULL(); 

				}
				break;
			case 35 :
				// PhoenixSQL.g:1:211: GROUP
				{
				mGROUP(); 

				}
				break;
			case 36 :
				// PhoenixSQL.g:1:217: HAVING
				{
				mHAVING(); 

				}
				break;
			case 37 :
				// PhoenixSQL.g:1:224: IF
				{
				mIF(); 

				}
				break;
			case 38 :
				// PhoenixSQL.g:1:227: ILIKE
				{
				mILIKE(); 

				}
				break;
			case 39 :
				// PhoenixSQL.g:1:233: IN
				{
				mIN(); 

				}
				break;
			case 40 :
				// PhoenixSQL.g:1:236: INCLUDE
				{
				mINCLUDE(); 

				}
				break;
			case 41 :
				// PhoenixSQL.g:1:244: INCREMENT
				{
				mINCREMENT(); 

				}
				break;
			case 42 :
				// PhoenixSQL.g:1:254: INDEX
				{
				mINDEX(); 

				}
				break;
			case 43 :
				// PhoenixSQL.g:1:260: INNER
				{
				mINNER(); 

				}
				break;
			case 44 :
				// PhoenixSQL.g:1:266: INTO
				{
				mINTO(); 

				}
				break;
			case 45 :
				// PhoenixSQL.g:1:271: IS
				{
				mIS(); 

				}
				break;
			case 46 :
				// PhoenixSQL.g:1:274: JOIN
				{
				mJOIN(); 

				}
				break;
			case 47 :
				// PhoenixSQL.g:1:279: KEY
				{
				mKEY(); 

				}
				break;
			case 48 :
				// PhoenixSQL.g:1:283: LAST
				{
				mLAST(); 

				}
				break;
			case 49 :
				// PhoenixSQL.g:1:288: LEFT
				{
				mLEFT(); 

				}
				break;
			case 50 :
				// PhoenixSQL.g:1:293: LIKE
				{
				mLIKE(); 

				}
				break;
			case 51 :
				// PhoenixSQL.g:1:298: LIMIT
				{
				mLIMIT(); 

				}
				break;
			case 52 :
				// PhoenixSQL.g:1:304: LOCAL
				{
				mLOCAL(); 

				}
				break;
			case 53 :
				// PhoenixSQL.g:1:310: MAXVALUE
				{
				mMAXVALUE(); 

				}
				break;
			case 54 :
				// PhoenixSQL.g:1:319: MINVALUE
				{
				mMINVALUE(); 

				}
				break;
			case 55 :
				// PhoenixSQL.g:1:328: NEXT
				{
				mNEXT(); 

				}
				break;
			case 56 :
				// PhoenixSQL.g:1:333: NOT
				{
				mNOT(); 

				}
				break;
			case 57 :
				// PhoenixSQL.g:1:337: NULL
				{
				mNULL(); 

				}
				break;
			case 58 :
				// PhoenixSQL.g:1:342: NULLS
				{
				mNULLS(); 

				}
				break;
			case 59 :
				// PhoenixSQL.g:1:348: ON
				{
				mON(); 

				}
				break;
			case 60 :
				// PhoenixSQL.g:1:351: OR
				{
				mOR(); 

				}
				break;
			case 61 :
				// PhoenixSQL.g:1:354: ORDER
				{
				mORDER(); 

				}
				break;
			case 62 :
				// PhoenixSQL.g:1:360: OUTER
				{
				mOUTER(); 

				}
				break;
			case 63 :
				// PhoenixSQL.g:1:366: PRIMARY
				{
				mPRIMARY(); 

				}
				break;
			case 64 :
				// PhoenixSQL.g:1:374: REBUILD
				{
				mREBUILD(); 

				}
				break;
			case 65 :
				// PhoenixSQL.g:1:382: RIGHT
				{
				mRIGHT(); 

				}
				break;
			case 66 :
				// PhoenixSQL.g:1:388: SELECT
				{
				mSELECT(); 

				}
				break;
			case 67 :
				// PhoenixSQL.g:1:395: SEQUENCE
				{
				mSEQUENCE(); 

				}
				break;
			case 68 :
				// PhoenixSQL.g:1:404: SET
				{
				mSET(); 

				}
				break;
			case 69 :
				// PhoenixSQL.g:1:408: SOME
				{
				mSOME(); 

				}
				break;
			case 70 :
				// PhoenixSQL.g:1:413: SPLIT
				{
				mSPLIT(); 

				}
				break;
			case 71 :
				// PhoenixSQL.g:1:419: START
				{
				mSTART(); 

				}
				break;
			case 72 :
				// PhoenixSQL.g:1:425: STATISTICS
				{
				mSTATISTICS(); 

				}
				break;
			case 73 :
				// PhoenixSQL.g:1:436: TABLE
				{
				mTABLE(); 

				}
				break;
			case 74 :
				// PhoenixSQL.g:1:442: TABLES
				{
				mTABLES(); 

				}
				break;
			case 75 :
				// PhoenixSQL.g:1:449: THEN
				{
				mTHEN(); 

				}
				break;
			case 76 :
				// PhoenixSQL.g:1:454: TRUE
				{
				mTRUE(); 

				}
				break;
			case 77 :
				// PhoenixSQL.g:1:459: UNUSABLE
				{
				mUNUSABLE(); 

				}
				break;
			case 78 :
				// PhoenixSQL.g:1:468: UPDATE
				{
				mUPDATE(); 

				}
				break;
			case 79 :
				// PhoenixSQL.g:1:475: UPSERT
				{
				mUPSERT(); 

				}
				break;
			case 80 :
				// PhoenixSQL.g:1:482: USABLE
				{
				mUSABLE(); 

				}
				break;
			case 81 :
				// PhoenixSQL.g:1:489: VALUE
				{
				mVALUE(); 

				}
				break;
			case 82 :
				// PhoenixSQL.g:1:495: VALUES
				{
				mVALUES(); 

				}
				break;
			case 83 :
				// PhoenixSQL.g:1:502: VIEW
				{
				mVIEW(); 

				}
				break;
			case 84 :
				// PhoenixSQL.g:1:507: WHEN
				{
				mWHEN(); 

				}
				break;
			case 85 :
				// PhoenixSQL.g:1:512: WHERE
				{
				mWHERE(); 

				}
				break;
			case 86 :
				// PhoenixSQL.g:1:518: WITH
				{
				mWITH(); 

				}
				break;
			case 87 :
				// PhoenixSQL.g:1:523: WITHIN
				{
				mWITHIN(); 

				}
				break;
			case 88 :
				// PhoenixSQL.g:1:530: HINT_START
				{
				mHINT_START(); 

				}
				break;
			case 89 :
				// PhoenixSQL.g:1:541: COMMENT_START
				{
				mCOMMENT_START(); 

				}
				break;
			case 90 :
				// PhoenixSQL.g:1:555: COMMENT_AND_HINT_END
				{
				mCOMMENT_AND_HINT_END(); 

				}
				break;
			case 91 :
				// PhoenixSQL.g:1:576: SL_COMMENT1
				{
				mSL_COMMENT1(); 

				}
				break;
			case 92 :
				// PhoenixSQL.g:1:588: SL_COMMENT2
				{
				mSL_COMMENT2(); 

				}
				break;
			case 93 :
				// PhoenixSQL.g:1:600: BIND_NAME
				{
				mBIND_NAME(); 

				}
				break;
			case 94 :
				// PhoenixSQL.g:1:610: NAME
				{
				mNAME(); 

				}
				break;
			case 95 :
				// PhoenixSQL.g:1:615: NUMBER
				{
				mNUMBER(); 

				}
				break;
			case 96 :
				// PhoenixSQL.g:1:622: LONG
				{
				mLONG(); 

				}
				break;
			case 97 :
				// PhoenixSQL.g:1:627: DECIMAL
				{
				mDECIMAL(); 

				}
				break;
			case 98 :
				// PhoenixSQL.g:1:635: DOUBLE
				{
				mDOUBLE(); 

				}
				break;
			case 99 :
				// PhoenixSQL.g:1:642: DOUBLE_QUOTE
				{
				mDOUBLE_QUOTE(); 

				}
				break;
			case 100 :
				// PhoenixSQL.g:1:655: EQ
				{
				mEQ(); 

				}
				break;
			case 101 :
				// PhoenixSQL.g:1:658: LT
				{
				mLT(); 

				}
				break;
			case 102 :
				// PhoenixSQL.g:1:661: GT
				{
				mGT(); 

				}
				break;
			case 103 :
				// PhoenixSQL.g:1:664: DOUBLE_EQ
				{
				mDOUBLE_EQ(); 

				}
				break;
			case 104 :
				// PhoenixSQL.g:1:674: NOEQ1
				{
				mNOEQ1(); 

				}
				break;
			case 105 :
				// PhoenixSQL.g:1:680: NOEQ2
				{
				mNOEQ2(); 

				}
				break;
			case 106 :
				// PhoenixSQL.g:1:686: CONCAT
				{
				mCONCAT(); 

				}
				break;
			case 107 :
				// PhoenixSQL.g:1:693: COMMA
				{
				mCOMMA(); 

				}
				break;
			case 108 :
				// PhoenixSQL.g:1:699: LPAREN
				{
				mLPAREN(); 

				}
				break;
			case 109 :
				// PhoenixSQL.g:1:706: RPAREN
				{
				mRPAREN(); 

				}
				break;
			case 110 :
				// PhoenixSQL.g:1:713: SEMICOLON
				{
				mSEMICOLON(); 

				}
				break;
			case 111 :
				// PhoenixSQL.g:1:723: COLON
				{
				mCOLON(); 

				}
				break;
			case 112 :
				// PhoenixSQL.g:1:729: QUESTION
				{
				mQUESTION(); 

				}
				break;
			case 113 :
				// PhoenixSQL.g:1:738: LSQUARE
				{
				mLSQUARE(); 

				}
				break;
			case 114 :
				// PhoenixSQL.g:1:746: RSQUARE
				{
				mRSQUARE(); 

				}
				break;
			case 115 :
				// PhoenixSQL.g:1:754: LCURLY
				{
				mLCURLY(); 

				}
				break;
			case 116 :
				// PhoenixSQL.g:1:761: RCURLY
				{
				mRCURLY(); 

				}
				break;
			case 117 :
				// PhoenixSQL.g:1:768: AT
				{
				mAT(); 

				}
				break;
			case 118 :
				// PhoenixSQL.g:1:771: TILDE
				{
				mTILDE(); 

				}
				break;
			case 119 :
				// PhoenixSQL.g:1:777: PLUS
				{
				mPLUS(); 

				}
				break;
			case 120 :
				// PhoenixSQL.g:1:782: MINUS
				{
				mMINUS(); 

				}
				break;
			case 121 :
				// PhoenixSQL.g:1:788: ASTERISK
				{
				mASTERISK(); 

				}
				break;
			case 122 :
				// PhoenixSQL.g:1:797: DIVIDE
				{
				mDIVIDE(); 

				}
				break;
			case 123 :
				// PhoenixSQL.g:1:804: PERCENT
				{
				mPERCENT(); 

				}
				break;
			case 124 :
				// PhoenixSQL.g:1:812: OUTER_JOIN
				{
				mOUTER_JOIN(); 

				}
				break;
			case 125 :
				// PhoenixSQL.g:1:823: STRING_LITERAL
				{
				mSTRING_LITERAL(); 

				}
				break;
			case 126 :
				// PhoenixSQL.g:1:838: WS
				{
				mWS(); 

				}
				break;
			case 127 :
				// PhoenixSQL.g:1:841: EOL
				{
				mEOL(); 

				}
				break;
			case 128 :
				// PhoenixSQL.g:1:845: ML_HINT
				{
				mML_HINT(); 

				}
				break;
			case 129 :
				// PhoenixSQL.g:1:853: ML_COMMENT
				{
				mML_COMMENT(); 

				}
				break;
			case 130 :
				// PhoenixSQL.g:1:864: SL_COMMENT
				{
				mSL_COMMENT(); 

				}
				break;
			case 131 :
				// PhoenixSQL.g:1:875: DOT
				{
				mDOT(); 

				}
				break;
			case 132 :
				// PhoenixSQL.g:1:879: OTHER
				{
				mOTHER(); 

				}
				break;

		}
	}


	protected DFA16 dfa16 = new DFA16(this);
	static final String DFA16_eotS =
		"\1\uffff\26\72\1\164\1\166\1\170\1\171\1\uffff\1\173\1\174\1\u0081\1\u0083"+
		"\1\u0085\1\uffff\2\64\1\uffff\1\u008b\13\uffff\1\64\3\uffff\4\72\1\u00a1"+
		"\1\uffff\1\72\1\u00a3\22\72\1\u00ba\1\72\1\u00c0\1\u00c1\13\72\1\u00ce"+
		"\1\u00d0\22\72\1\u00e7\1\u00e9\3\uffff\1\u00eb\5\uffff\1\174\2\uffff\1"+
		"\u00ec\31\uffff\1\u00ee\1\u00ef\1\72\1\u00f1\1\u00f2\1\72\1\u00f4\1\uffff"+
		"\1\72\1\uffff\14\72\1\u0105\4\72\1\u010a\4\72\1\uffff\5\72\2\uffff\1\72"+
		"\1\u0116\10\72\1\u011f\1\72\1\uffff\1\72\1\uffff\6\72\1\u0128\16\72\1"+
		"\u0139\11\uffff\1\72\2\uffff\1\72\1\uffff\3\72\1\u0140\1\u0141\6\72\1"+
		"\u0148\2\72\1\u014b\1\u014c\1\uffff\4\72\1\uffff\1\u0151\1\u0152\7\72"+
		"\1\u015a\1\u015b\1\uffff\1\u015c\1\u015d\1\u015e\4\72\1\u0163\1\uffff"+
		"\1\u0165\7\72\1\uffff\1\u016d\4\72\1\u0172\1\u0173\5\72\1\u0179\1\u017a"+
		"\1\72\1\u017d\2\uffff\1\u017e\1\u017f\1\72\1\u0181\1\72\2\uffff\4\72\1"+
		"\u0187\1\72\1\uffff\2\72\2\uffff\2\72\1\u018d\1\u018e\2\uffff\1\u018f"+
		"\1\72\1\u0191\2\72\1\u0194\1\u0195\5\uffff\1\u0196\1\u0197\2\72\1\uffff"+
		"\1\u019a\1\uffff\1\u019b\1\u019c\2\72\1\u019f\2\72\1\uffff\1\u01a2\1\u01a3"+
		"\1\72\1\u01a6\2\uffff\4\72\1\u01ac\2\uffff\1\u01ad\1\72\3\uffff\1\72\1"+
		"\uffff\1\72\1\u01b2\1\72\1\u01b4\1\72\1\uffff\1\u01b6\2\72\1\u01b9\1\72"+
		"\3\uffff\1\u01bb\1\uffff\2\72\4\uffff\2\72\3\uffff\2\72\1\uffff\1\u01c2"+
		"\1\72\2\uffff\1\72\1\u01c5\1\uffff\1\72\1\u01c7\1\u01c8\1\u01c9\1\u01ca"+
		"\2\uffff\1\u01cb\1\u01cc\1\u01cd\1\u01ce\1\uffff\1\72\1\uffff\1\u01d0"+
		"\1\uffff\1\u01d1\1\72\1\uffff\1\u01d3\1\uffff\1\u01d4\3\72\1\u01d8\1\u01d9"+
		"\1\uffff\2\72\1\uffff\1\72\10\uffff\1\72\2\uffff\1\u01de\2\uffff\1\72"+
		"\1\u01e0\1\u01e1\2\uffff\1\u01e2\1\72\1\u01e4\1\72\1\uffff\1\u01e6\3\uffff"+
		"\1\72\1\uffff\1\u01e8\1\uffff\1\u01e9\2\uffff";
	static final String DFA16_eofS =
		"\u01ea\uffff";
	static final String DFA16_minS =
		"\1\0\1\144\1\145\1\141\1\145\1\154\1\141\1\162\1\141\1\146\1\157\1\145"+
		"\2\141\1\145\1\156\1\162\2\145\1\141\1\156\1\141\1\150\1\52\1\57\1\55"+
		"\1\60\1\uffff\1\0\1\56\1\60\1\75\1\76\1\uffff\1\75\1\174\1\uffff\1\53"+
		"\13\uffff\1\0\3\uffff\1\144\1\154\1\144\1\162\1\60\1\uffff\1\164\1\60"+
		"\1\143\1\154\1\145\1\162\1\143\1\154\1\163\1\157\1\163\1\144\1\151\1\154"+
		"\2\162\1\157\1\154\1\157\1\166\1\60\1\151\2\60\1\151\1\171\1\163\1\146"+
		"\1\153\1\143\1\170\1\156\1\170\1\164\1\154\2\60\1\164\1\151\1\142\1\147"+
		"\1\154\1\155\1\154\1\141\1\142\1\145\2\165\1\144\1\141\1\154\2\145\1\164"+
		"\2\0\3\uffff\1\0\5\uffff\1\56\1\uffff\2\60\31\uffff\2\60\1\145\2\60\1"+
		"\141\1\60\1\uffff\1\167\1\uffff\1\150\1\143\1\165\1\163\1\141\1\162\1"+
		"\154\1\145\1\143\1\141\1\160\1\145\1\60\1\163\1\154\2\163\1\60\1\155\1"+
		"\154\1\165\1\151\1\uffff\1\153\1\154\2\145\1\157\2\uffff\1\156\1\60\2"+
		"\164\1\145\1\151\1\141\2\166\1\164\1\60\1\154\1\uffff\1\145\1\uffff\1"+
		"\145\1\155\1\165\1\150\1\145\1\165\1\60\1\145\1\151\1\162\1\154\1\156"+
		"\1\145\1\163\1\141\1\145\1\142\1\165\1\167\1\156\1\150\1\0\11\uffff\1"+
		"\162\2\uffff\1\171\1\uffff\2\145\1\141\2\60\1\155\2\164\2\145\1\164\1"+
		"\60\1\142\1\151\2\60\1\uffff\1\164\1\141\1\145\1\164\1\uffff\2\60\1\160"+
		"\1\156\1\145\1\165\1\145\1\170\1\162\2\60\1\uffff\3\60\1\164\1\154\2\141"+
		"\1\60\1\uffff\1\60\2\162\1\141\1\151\1\164\1\143\1\145\1\uffff\1\60\2"+
		"\164\1\151\1\145\2\60\1\141\1\164\1\162\1\154\1\145\2\60\1\145\1\60\2"+
		"\uffff\2\60\1\145\1\60\1\144\2\uffff\1\156\1\162\1\145\1\156\1\60\1\145"+
		"\1\uffff\1\154\1\156\2\uffff\1\163\1\151\2\60\2\uffff\1\60\1\147\1\60"+
		"\1\144\1\155\2\60\5\uffff\2\60\2\154\1\uffff\1\60\1\uffff\2\60\1\162\1"+
		"\154\1\60\1\164\1\156\1\uffff\2\60\1\163\1\60\2\uffff\1\142\1\145\1\164"+
		"\1\145\1\60\2\uffff\1\60\1\156\3\uffff\1\156\1\uffff\1\145\1\60\1\141"+
		"\1\60\1\164\1\uffff\1\60\1\145\1\143\1\60\1\156\3\uffff\1\60\1\uffff\2"+
		"\145\4\uffff\2\165\3\uffff\1\171\1\144\1\uffff\1\60\1\143\2\uffff\1\164"+
		"\1\60\1\uffff\1\154\4\60\2\uffff\4\60\1\uffff\1\151\1\uffff\1\60\1\uffff"+
		"\1\60\1\164\1\uffff\1\60\1\uffff\1\60\1\156\2\145\2\60\1\uffff\1\145\1"+
		"\151\1\uffff\1\145\10\uffff\1\156\2\uffff\1\60\2\uffff\1\164\2\60\2\uffff"+
		"\1\60\1\143\1\60\1\164\1\uffff\1\60\3\uffff\1\163\1\uffff\1\60\1\uffff"+
		"\1\60\2\uffff";
	static final String DFA16_maxS =
		"\1\uffff\1\163\2\171\1\162\1\170\1\165\1\162\1\141\1\163\1\157\1\145\1"+
		"\157\1\151\2\165\1\162\1\151\1\164\1\162\1\163\2\151\2\57\1\55\1\71\1"+
		"\uffff\1\uffff\1\154\1\71\1\75\1\76\1\uffff\1\75\1\174\1\uffff\1\53\13"+
		"\uffff\1\uffff\3\uffff\1\144\1\164\1\171\1\162\1\ufffe\1\uffff\1\164\1"+
		"\ufffe\1\163\1\156\1\145\1\162\1\143\2\163\1\157\1\163\1\144\1\160\1\154"+
		"\2\162\1\157\1\154\1\157\1\166\1\ufffe\1\151\2\ufffe\1\151\1\171\1\163"+
		"\1\146\1\155\1\143\1\170\1\156\1\170\1\164\1\154\2\ufffe\1\164\1\151\1"+
		"\142\1\147\1\164\1\155\1\154\1\141\1\142\1\145\2\165\1\163\1\141\1\154"+
		"\2\145\1\164\2\uffff\3\uffff\1\uffff\5\uffff\1\154\1\uffff\1\71\1\144"+
		"\31\uffff\2\ufffe\1\145\2\ufffe\1\141\1\ufffe\1\uffff\1\167\1\uffff\1"+
		"\150\1\164\1\165\1\163\1\141\1\162\1\154\1\145\1\143\1\164\1\160\1\145"+
		"\1\ufffe\1\163\1\154\2\163\1\ufffe\1\155\1\154\1\165\1\151\1\uffff\1\153"+
		"\1\162\2\145\1\157\2\uffff\1\156\1\ufffe\2\164\1\145\1\151\1\141\2\166"+
		"\1\164\1\ufffe\1\154\1\uffff\1\145\1\uffff\1\145\1\155\1\165\1\150\1\145"+
		"\1\165\1\ufffe\1\145\1\151\1\164\1\154\1\156\1\145\1\163\1\141\1\145\1"+
		"\142\1\165\1\167\1\162\1\150\1\uffff\11\uffff\1\162\2\uffff\1\171\1\uffff"+
		"\2\145\1\141\2\ufffe\1\155\2\164\2\145\1\164\1\ufffe\1\142\1\151\2\ufffe"+
		"\1\uffff\1\164\1\141\1\145\1\164\1\uffff\2\ufffe\1\160\1\156\1\145\1\165"+
		"\1\145\1\170\1\162\2\ufffe\1\uffff\3\ufffe\1\164\1\154\2\141\1\ufffe\1"+
		"\uffff\1\ufffe\2\162\1\141\1\151\1\164\1\143\1\145\1\uffff\1\ufffe\2\164"+
		"\1\151\1\145\2\ufffe\1\141\1\164\1\162\1\154\1\145\2\ufffe\1\145\1\ufffe"+
		"\2\uffff\2\ufffe\1\145\1\ufffe\1\144\2\uffff\1\156\1\162\1\145\1\156\1"+
		"\ufffe\1\145\1\uffff\1\154\1\156\2\uffff\1\163\1\151\2\ufffe\2\uffff\1"+
		"\ufffe\1\147\1\ufffe\1\144\1\155\2\ufffe\5\uffff\2\ufffe\2\154\1\uffff"+
		"\1\ufffe\1\uffff\2\ufffe\1\162\1\154\1\ufffe\1\164\1\156\1\uffff\2\ufffe"+
		"\1\163\1\ufffe\2\uffff\1\142\1\145\1\164\1\145\1\ufffe\2\uffff\1\ufffe"+
		"\1\156\3\uffff\1\156\1\uffff\1\145\1\ufffe\1\141\1\ufffe\1\164\1\uffff"+
		"\1\ufffe\1\145\1\143\1\ufffe\1\156\3\uffff\1\ufffe\1\uffff\2\145\4\uffff"+
		"\2\165\3\uffff\1\171\1\144\1\uffff\1\ufffe\1\143\2\uffff\1\164\1\ufffe"+
		"\1\uffff\1\154\4\ufffe\2\uffff\4\ufffe\1\uffff\1\151\1\uffff\1\ufffe\1"+
		"\uffff\1\ufffe\1\164\1\uffff\1\ufffe\1\uffff\1\ufffe\1\156\2\145\2\ufffe"+
		"\1\uffff\1\145\1\151\1\uffff\1\145\10\uffff\1\156\2\uffff\1\ufffe\2\uffff"+
		"\1\164\2\ufffe\2\uffff\1\ufffe\1\143\1\ufffe\1\164\1\uffff\1\ufffe\3\uffff"+
		"\1\163\1\uffff\1\ufffe\1\uffff\1\ufffe\2\uffff";
	static final String DFA16_acceptS =
		"\33\uffff\1\136\5\uffff\1\146\2\uffff\1\153\1\uffff\1\155\1\156\1\160"+
		"\1\161\1\162\1\163\1\164\1\165\1\166\1\167\1\173\1\uffff\1\176\1\177\1"+
		"\u0084\5\uffff\1\136\71\uffff\1\172\1\132\1\171\1\uffff\1\170\1\157\1"+
		"\135\1\143\1\137\1\uffff\1\140\2\uffff\1\u0083\1\147\1\144\1\151\1\145"+
		"\1\146\1\150\1\152\1\153\1\174\1\154\1\155\1\156\1\160\1\161\1\162\1\163"+
		"\1\164\1\165\1\166\1\167\1\173\1\175\1\176\1\177\7\uffff\1\7\1\uffff\1"+
		"\12\26\uffff\1\45\5\uffff\1\47\1\55\14\uffff\1\73\1\uffff\1\74\26\uffff"+
		"\1\131\1\u0081\1\133\1\u0082\1\134\1\141\1\142\1\1\1\2\1\uffff\1\4\1\5"+
		"\1\uffff\1\10\20\uffff\1\33\4\uffff\1\40\13\uffff\1\57\10\uffff\1\70\10"+
		"\uffff\1\104\20\uffff\1\130\1\u0080\5\uffff\1\15\1\16\6\uffff\1\26\2\uffff"+
		"\1\31\1\32\4\uffff\1\41\1\42\7\uffff\1\54\1\56\1\60\1\61\1\62\4\uffff"+
		"\1\67\1\uffff\1\71\7\uffff\1\105\4\uffff\1\113\1\114\5\uffff\1\123\1\124"+
		"\2\uffff\1\126\1\3\1\6\1\uffff\1\13\5\uffff\1\24\5\uffff\1\36\1\37\1\43"+
		"\1\uffff\1\46\2\uffff\1\52\1\53\1\63\1\64\2\uffff\1\72\1\75\1\76\2\uffff"+
		"\1\101\2\uffff\1\106\1\107\2\uffff\1\111\5\uffff\1\121\1\125\4\uffff\1"+
		"\17\1\uffff\1\22\1\uffff\1\25\2\uffff\1\34\1\uffff\1\44\6\uffff\1\102"+
		"\2\uffff\1\112\1\uffff\1\116\1\117\1\120\1\122\1\127\1\11\1\14\1\20\1"+
		"\uffff\1\23\1\27\1\uffff\1\35\1\50\3\uffff\1\77\1\100\4\uffff\1\30\1\uffff"+
		"\1\65\1\66\1\103\1\uffff\1\115\1\uffff\1\51\1\uffff\1\21\1\110";
	static final String DFA16_specialS =
		"\1\5\33\uffff\1\2\24\uffff\1\6\100\uffff\1\4\1\0\3\uffff\1\1\156\uffff"+
		"\1\3\u0103\uffff}>";
	static final String[] DFA16_transitionS = {
			"\11\64\1\62\1\63\2\64\1\63\22\64\1\62\1\42\1\34\2\64\1\60\1\64\1\61\1"+
			"\45\1\46\1\30\1\57\1\44\1\31\1\36\1\27\12\35\1\32\1\47\1\40\1\37\1\41"+
			"\1\50\1\55\32\33\1\51\1\64\1\52\3\64\1\1\1\2\1\3\1\4\1\5\1\6\1\7\1\10"+
			"\1\11\1\12\1\13\1\14\1\15\1\16\1\17\1\20\1\33\1\21\1\22\1\23\1\24\1\25"+
			"\1\26\3\33\1\53\1\43\1\54\1\56\uff81\64",
			"\1\65\7\uffff\1\66\1\uffff\1\67\3\uffff\1\70\1\71",
			"\1\73\23\uffff\1\74",
			"\1\75\15\uffff\1\76\2\uffff\1\77\2\uffff\1\100\3\uffff\1\101",
			"\1\102\3\uffff\1\103\10\uffff\1\104",
			"\1\105\1\uffff\1\106\11\uffff\1\107",
			"\1\110\7\uffff\1\111\5\uffff\1\112\2\uffff\1\113\2\uffff\1\114",
			"\1\115",
			"\1\116",
			"\1\117\5\uffff\1\120\1\uffff\1\121\4\uffff\1\122",
			"\1\123",
			"\1\124",
			"\1\125\3\uffff\1\126\3\uffff\1\127\5\uffff\1\130",
			"\1\131\7\uffff\1\132",
			"\1\133\11\uffff\1\134\5\uffff\1\135",
			"\1\136\3\uffff\1\137\2\uffff\1\140",
			"\1\141",
			"\1\142\3\uffff\1\143",
			"\1\144\11\uffff\1\145\1\146\3\uffff\1\147",
			"\1\150\6\uffff\1\151\11\uffff\1\152",
			"\1\153\1\uffff\1\154\2\uffff\1\155",
			"\1\156\7\uffff\1\157",
			"\1\160\1\161",
			"\1\162\4\uffff\1\163",
			"\1\165",
			"\1\167",
			"\12\172",
			"",
			"\0\72",
			"\1\177\1\uffff\12\175\22\uffff\1\176\37\uffff\1\176",
			"\12\u0080",
			"\1\u0082",
			"\1\u0084",
			"",
			"\1\u0087",
			"\1\u0088",
			"",
			"\1\u008a",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"\0\u0097",
			"",
			"",
			"",
			"\1\u009a",
			"\1\u009b\7\uffff\1\u009c",
			"\1\u009d\24\uffff\1\u009e",
			"\1\u009f",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\2\72\1\u00a0\27\72\5\uffff"+
			"\uff7f\72",
			"",
			"\1\u00a2",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u00a4\17\uffff\1\u00a5",
			"\1\u00a6\1\uffff\1\u00a7",
			"\1\u00a8",
			"\1\u00a9",
			"\1\u00aa",
			"\1\u00ab\6\uffff\1\u00ac",
			"\1\u00ad",
			"\1\u00ae",
			"\1\u00af",
			"\1\u00b0",
			"\1\u00b1\6\uffff\1\u00b2",
			"\1\u00b3",
			"\1\u00b4",
			"\1\u00b5",
			"\1\u00b6",
			"\1\u00b7",
			"\1\u00b8",
			"\1\u00b9",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u00bb",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\2\72\1\u00bc\1\u00bd\11\72"+
			"\1\u00be\5\72\1\u00bf\6\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u00c2",
			"\1\u00c3",
			"\1\u00c4",
			"\1\u00c5",
			"\1\u00c6\1\uffff\1\u00c7",
			"\1\u00c8",
			"\1\u00c9",
			"\1\u00ca",
			"\1\u00cb",
			"\1\u00cc",
			"\1\u00cd",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\3\72\1\u00cf\26\72\5\uffff"+
			"\uff7f\72",
			"\1\u00d1",
			"\1\u00d2",
			"\1\u00d3",
			"\1\u00d4",
			"\1\u00d5\4\uffff\1\u00d6\2\uffff\1\u00d7",
			"\1\u00d8",
			"\1\u00d9",
			"\1\u00da",
			"\1\u00db",
			"\1\u00dc",
			"\1\u00dd",
			"\1\u00de",
			"\1\u00df\16\uffff\1\u00e0",
			"\1\u00e1",
			"\1\u00e2",
			"\1\u00e3",
			"\1\u00e4",
			"\1\u00e5",
			"\53\u00e8\1\u00e6\uffd4\u00e8",
			"\0\u00ea",
			"",
			"",
			"",
			"\0\u00ea",
			"",
			"",
			"",
			"",
			"",
			"\1\177\1\uffff\12\175\22\uffff\1\176\37\uffff\1\176",
			"",
			"\12\u0080",
			"\12\u0080\12\uffff\1\u00ed\37\uffff\1\u00ed",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u00f0",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u00f3",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\1\u00f5",
			"",
			"\1\u00f6",
			"\1\u00f7\1\uffff\1\u00f8\16\uffff\1\u00f9",
			"\1\u00fa",
			"\1\u00fb",
			"\1\u00fc",
			"\1\u00fd",
			"\1\u00fe",
			"\1\u00ff",
			"\1\u0100",
			"\1\u0101\22\uffff\1\u0102",
			"\1\u0103",
			"\1\u0104",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0106",
			"\1\u0107",
			"\1\u0108",
			"\1\u0109",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u010b",
			"\1\u010c",
			"\1\u010d",
			"\1\u010e",
			"",
			"\1\u010f",
			"\1\u0110\5\uffff\1\u0111",
			"\1\u0112",
			"\1\u0113",
			"\1\u0114",
			"",
			"",
			"\1\u0115",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0117",
			"\1\u0118",
			"\1\u0119",
			"\1\u011a",
			"\1\u011b",
			"\1\u011c",
			"\1\u011d",
			"\1\u011e",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0120",
			"",
			"\1\u0121",
			"",
			"\1\u0122",
			"\1\u0123",
			"\1\u0124",
			"\1\u0125",
			"\1\u0126",
			"\1\u0127",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0129",
			"\1\u012a",
			"\1\u012b\1\uffff\1\u012c",
			"\1\u012d",
			"\1\u012e",
			"\1\u012f",
			"\1\u0130",
			"\1\u0131",
			"\1\u0132",
			"\1\u0133",
			"\1\u0134",
			"\1\u0135",
			"\1\u0136\3\uffff\1\u0137",
			"\1\u0138",
			"\0\u013a",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\u013b",
			"",
			"",
			"\1\u013c",
			"",
			"\1\u013d",
			"\1\u013e",
			"\1\u013f",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0142",
			"\1\u0143",
			"\1\u0144",
			"\1\u0145",
			"\1\u0146",
			"\1\u0147",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0149",
			"\1\u014a",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\1\u014d",
			"\1\u014e",
			"\1\u014f",
			"\1\u0150",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0153",
			"\1\u0154",
			"\1\u0155",
			"\1\u0156",
			"\1\u0157",
			"\1\u0158",
			"\1\u0159",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u015f",
			"\1\u0160",
			"\1\u0161",
			"\1\u0162",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\22\72\1\u0164\7\72\5\uffff"+
			"\uff7f\72",
			"\1\u0166",
			"\1\u0167",
			"\1\u0168",
			"\1\u0169",
			"\1\u016a",
			"\1\u016b",
			"\1\u016c",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u016e",
			"\1\u016f",
			"\1\u0170",
			"\1\u0171",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0174",
			"\1\u0175",
			"\1\u0176",
			"\1\u0177",
			"\1\u0178",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u017b",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\10\72\1\u017c\21\72\5\uffff"+
			"\uff7f\72",
			"",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0180",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0182",
			"",
			"",
			"\1\u0183",
			"\1\u0184",
			"\1\u0185",
			"\1\u0186",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0188",
			"",
			"\1\u0189",
			"\1\u018a",
			"",
			"",
			"\1\u018b",
			"\1\u018c",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0190",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0192",
			"\1\u0193",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"",
			"",
			"",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u0198",
			"\1\u0199",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u019d",
			"\1\u019e",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u01a0",
			"\1\u01a1",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u01a4",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\22\72\1\u01a5\7\72\5\uffff"+
			"\uff7f\72",
			"",
			"",
			"\1\u01a7",
			"\1\u01a8",
			"\1\u01a9",
			"\1\u01aa",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\22\72\1\u01ab\7\72\5\uffff"+
			"\uff7f\72",
			"",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u01ae",
			"",
			"",
			"",
			"\1\u01af",
			"",
			"\1\u01b0",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\22\72\1\u01b1\7\72\5\uffff"+
			"\uff7f\72",
			"\1\u01b3",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u01b5",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u01b7",
			"\1\u01b8",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u01ba",
			"",
			"",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\1\u01bc",
			"\1\u01bd",
			"",
			"",
			"",
			"",
			"\1\u01be",
			"\1\u01bf",
			"",
			"",
			"",
			"\1\u01c0",
			"\1\u01c1",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u01c3",
			"",
			"",
			"\1\u01c4",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\1\u01c6",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\1\u01cf",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u01d2",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u01d5",
			"\1\u01d6",
			"\1\u01d7",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\1\u01da",
			"\1\u01db",
			"",
			"\1\u01dc",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\u01dd",
			"",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"",
			"\1\u01df",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u01e3",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"\1\u01e5",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"",
			"",
			"\1\u01e7",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			"\12\72\7\uffff\32\72\4\uffff\1\72\1\uffff\32\72\5\uffff\uff7f\72",
			"",
			""
	};

	static final short[] DFA16_eot = DFA.unpackEncodedString(DFA16_eotS);
	static final short[] DFA16_eof = DFA.unpackEncodedString(DFA16_eofS);
	static final char[] DFA16_min = DFA.unpackEncodedStringToUnsignedChars(DFA16_minS);
	static final char[] DFA16_max = DFA.unpackEncodedStringToUnsignedChars(DFA16_maxS);
	static final short[] DFA16_accept = DFA.unpackEncodedString(DFA16_acceptS);
	static final short[] DFA16_special = DFA.unpackEncodedString(DFA16_specialS);
	static final short[][] DFA16_transition;

	static {
		int numStates = DFA16_transitionS.length;
		DFA16_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA16_transition[i] = DFA.unpackEncodedString(DFA16_transitionS[i]);
		}
	}

	protected class DFA16 extends DFA {

		public DFA16(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 16;
			this.eot = DFA16_eot;
			this.eof = DFA16_eof;
			this.min = DFA16_min;
			this.max = DFA16_max;
			this.accept = DFA16_accept;
			this.special = DFA16_special;
			this.transition = DFA16_transition;
		}
		@Override
		public String getDescription() {
			return "1:1: Tokens : ( ADD | ALL | ALTER | AND | ANY | ARRAY | AS | ASC | BETWEEN | BY | CACHE | CASCADE | CASE | CAST | COLUMN | COLUMNS | CONSTRAINT | CREATE | CURRENT | CYCLE | DELETE | DESC | DISABLE | DISTINCT | DROP | ELSE | END | EXISTS | EXPLAIN | FALSE | FIRST | FOR | FROM | FULL | GROUP | HAVING | IF | ILIKE | IN | INCLUDE | INCREMENT | INDEX | INNER | INTO | IS | JOIN | KEY | LAST | LEFT | LIKE | LIMIT | LOCAL | MAXVALUE | MINVALUE | NEXT | NOT | NULL | NULLS | ON | OR | ORDER | OUTER | PRIMARY | REBUILD | RIGHT | SELECT | SEQUENCE | SET | SOME | SPLIT | START | STATISTICS | TABLE | TABLES | THEN | TRUE | UNUSABLE | UPDATE | UPSERT | USABLE | VALUE | VALUES | VIEW | WHEN | WHERE | WITH | WITHIN | HINT_START | COMMENT_START | COMMENT_AND_HINT_END | SL_COMMENT1 | SL_COMMENT2 | BIND_NAME | NAME | NUMBER | LONG | DECIMAL | DOUBLE | DOUBLE_QUOTE | EQ | LT | GT | DOUBLE_EQ | NOEQ1 | NOEQ2 | CONCAT | COMMA | LPAREN | RPAREN | SEMICOLON | COLON | QUESTION | LSQUARE | RSQUARE | LCURLY | RCURLY | AT | TILDE | PLUS | MINUS | ASTERISK | DIVIDE | PERCENT | OUTER_JOIN | STRING_LITERAL | WS | EOL | ML_HINT | ML_COMMENT | SL_COMMENT | DOT | OTHER );";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			IntStream input = _input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA16_115 = input.LA(1);
						s = -1;
						if ( ((LA16_115 >= '\u0000' && LA16_115 <= '\uFFFF')) ) {s = 234;}
						else s = 233;
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA16_119 = input.LA(1);
						s = -1;
						if ( ((LA16_119 >= '\u0000' && LA16_119 <= '\uFFFF')) ) {s = 234;}
						else s = 235;
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA16_28 = input.LA(1);
						s = -1;
						if ( ((LA16_28 >= '\u0000' && LA16_28 <= '\uFFFF')) ) {s = 58;}
						else s = 123;
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA16_230 = input.LA(1);
						s = -1;
						if ( ((LA16_230 >= '\u0000' && LA16_230 <= '\uFFFF')) ) {s = 314;}
						else s = 313;
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA16_114 = input.LA(1);
						s = -1;
						if ( (LA16_114=='+') ) {s = 230;}
						else if ( ((LA16_114 >= '\u0000' && LA16_114 <= '*')||(LA16_114 >= ',' && LA16_114 <= '\uFFFF')) ) {s = 232;}
						else s = 231;
						if ( s>=0 ) return s;
						break;

					case 5 : 
						int LA16_0 = input.LA(1);
						s = -1;
						if ( (LA16_0=='a') ) {s = 1;}
						else if ( (LA16_0=='b') ) {s = 2;}
						else if ( (LA16_0=='c') ) {s = 3;}
						else if ( (LA16_0=='d') ) {s = 4;}
						else if ( (LA16_0=='e') ) {s = 5;}
						else if ( (LA16_0=='f') ) {s = 6;}
						else if ( (LA16_0=='g') ) {s = 7;}
						else if ( (LA16_0=='h') ) {s = 8;}
						else if ( (LA16_0=='i') ) {s = 9;}
						else if ( (LA16_0=='j') ) {s = 10;}
						else if ( (LA16_0=='k') ) {s = 11;}
						else if ( (LA16_0=='l') ) {s = 12;}
						else if ( (LA16_0=='m') ) {s = 13;}
						else if ( (LA16_0=='n') ) {s = 14;}
						else if ( (LA16_0=='o') ) {s = 15;}
						else if ( (LA16_0=='p') ) {s = 16;}
						else if ( (LA16_0=='r') ) {s = 17;}
						else if ( (LA16_0=='s') ) {s = 18;}
						else if ( (LA16_0=='t') ) {s = 19;}
						else if ( (LA16_0=='u') ) {s = 20;}
						else if ( (LA16_0=='v') ) {s = 21;}
						else if ( (LA16_0=='w') ) {s = 22;}
						else if ( (LA16_0=='/') ) {s = 23;}
						else if ( (LA16_0=='*') ) {s = 24;}
						else if ( (LA16_0=='-') ) {s = 25;}
						else if ( (LA16_0==':') ) {s = 26;}
						else if ( ((LA16_0 >= 'A' && LA16_0 <= 'Z')||LA16_0=='q'||(LA16_0 >= 'x' && LA16_0 <= 'z')) ) {s = 27;}
						else if ( (LA16_0=='\"') ) {s = 28;}
						else if ( ((LA16_0 >= '0' && LA16_0 <= '9')) ) {s = 29;}
						else if ( (LA16_0=='.') ) {s = 30;}
						else if ( (LA16_0=='=') ) {s = 31;}
						else if ( (LA16_0=='<') ) {s = 32;}
						else if ( (LA16_0=='>') ) {s = 33;}
						else if ( (LA16_0=='!') ) {s = 34;}
						else if ( (LA16_0=='|') ) {s = 35;}
						else if ( (LA16_0==',') ) {s = 36;}
						else if ( (LA16_0=='(') ) {s = 37;}
						else if ( (LA16_0==')') ) {s = 38;}
						else if ( (LA16_0==';') ) {s = 39;}
						else if ( (LA16_0=='?') ) {s = 40;}
						else if ( (LA16_0=='[') ) {s = 41;}
						else if ( (LA16_0==']') ) {s = 42;}
						else if ( (LA16_0=='{') ) {s = 43;}
						else if ( (LA16_0=='}') ) {s = 44;}
						else if ( (LA16_0=='@') ) {s = 45;}
						else if ( (LA16_0=='~') ) {s = 46;}
						else if ( (LA16_0=='+') ) {s = 47;}
						else if ( (LA16_0=='%') ) {s = 48;}
						else if ( (LA16_0=='\'') ) {s = 49;}
						else if ( (LA16_0=='\t'||LA16_0==' ') ) {s = 50;}
						else if ( (LA16_0=='\n'||LA16_0=='\r') ) {s = 51;}
						else if ( ((LA16_0 >= '\u0000' && LA16_0 <= '\b')||(LA16_0 >= '\u000B' && LA16_0 <= '\f')||(LA16_0 >= '\u000E' && LA16_0 <= '\u001F')||(LA16_0 >= '#' && LA16_0 <= '$')||LA16_0=='&'||LA16_0=='\\'||(LA16_0 >= '^' && LA16_0 <= '`')||(LA16_0 >= '\u007F' && LA16_0 <= '\uFFFF')) ) {s = 52;}
						if ( s>=0 ) return s;
						break;

					case 6 : 
						int LA16_49 = input.LA(1);
						s = -1;
						if ( ((LA16_49 >= '\u0000' && LA16_49 <= '\uFFFF')) ) {s = 151;}
						else s = 52;
						if ( s>=0 ) return s;
						break;
			}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 16, _s, input);
			error(nvae);
			throw nvae;
		}
	}

}
